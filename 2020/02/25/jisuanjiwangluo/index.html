<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="John Doe"><meta name="renderer" content="webkit"><meta name="copyright" content="John Doe"><meta name="keywords" content="Hexo"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>驰哥趣谈计算机网络 · Mr.Liu's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1525175323,4282711120&amp;fm=26&amp;gp=0.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">行者自远</div><div class="profile-signature">码出行云流水般的感觉</div><div class="friends"><div>FRIENDS</div><span><a href="liujunchi-bot.github.io" target="_black">mygithub</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1579025644130&amp;di=91083c502a018151c4baf71913b3c3fd&amp;imgtype=0&amp;src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201303%2F10%2F20130310192322_dCEtP.jpeg);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Liu's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a><a href="/categories/">Categories</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a><a href="/categories/">Categories</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">驰哥趣谈计算机网络</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2020-02-25</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Basics"> Basics</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">21.4k</span> | Reading time: <span class="post-count">79</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>[TOC]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计网到底是个啥"><a href="#计网到底是个啥" class="headerlink" title="计网到底是个啥"></a>计网到底是个啥</h2><p>1.定义：计算机网络主要是由一些通用的，可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增大的应用(灵活可拓展性)。</p>
<p>2.分类：计算机网络在我们日常生活当中也是非常容易见到的，比如说我们可以连接WIFI，发个消息，看看手机网站都是依赖于计算机网络，其主要有以下两种分类：</p>
<table>
<thead>
<tr>
<th>根据使用范围</th>
<th>根据使用者</th>
</tr>
</thead>
<tbody><tr>
<td>广域网(跨省，跨国)</td>
<td>公用网络</td>
</tr>
<tr>
<td>城域网(跨城市)</td>
<td></td>
</tr>
<tr>
<td>局域网(家庭或者公司)</td>
<td>专用网络</td>
</tr>
</tbody></table>
<p><strong>既然这里面由广域网，城域网，局域网这三种，那么这三种之间又是如何通信的呢，比如说局域网与局域网，局域网与城域网之间的信息交互，如何实现？先把问题留在这，后面会详细提到。</strong></p>
<h2 id="计网发展简史"><a href="#计网发展简史" class="headerlink" title="计网发展简史"></a>计网发展简史</h2><p>欲知其谁，可以了解它的过去。</p>
<h3 id="计算机网络的发展-四个阶段"><a href="#计算机网络的发展-四个阶段" class="headerlink" title="计算机网络的发展(四个阶段)"></a>计算机网络的发展(四个阶段)</h3><ul>
<li><strong>第一阶段：面向终端的计算机网络(20世纪50年代到60年代)</strong><br>在这个阶段那，<strong>主要是以主机为中心，实现对各个终端的通信。</strong>终端围绕着主机分散在各处，各个终端通过通信线路共享主机的硬件和软件资源</li>
</ul>
<p><img src="/2020/02/25/jisuanjiwangluo/1.jpg" alt="面向终端的计算机网络"></p>
<p>这种模式很容易维护，把主机当成爸爸来养好，系统基本就没什么大问题了，但是呢，我们可以发现，以主机为中心，也就是说我干什么都是看主机的眼色(发数据，处理数据等)，这样会使得传输的效率受到了限制，因为这全部<strong>依赖于主机的性能和可靠性，对主机的依赖性很大</strong>，主机一倒，全部都玩完，而且是各个终端连接到主机，这个过程的<strong>通信线路开销也比较大，利用率低。</strong></p>
<ul>
<li><strong>第二阶段：分组交换网,多台计算机互连(二十世纪60年代中期到70年代末)</strong><br>在这个阶段，若干个计算机利用通信电路相互连接形成一个系统，实现了计算机与计算机之间的通信。分组交换网又是什么？</li>
</ul>
<blockquote>
<p>分组交换网由通信子网和资源子网组成，以通信子网为中心，不仅共享通信子网的资源，还可共享资源子网的硬件和软件资源。网络的共享采用排队方式，即由结点的分组交换机负责分组的存储转发和路由选择，给两个进行通信的用户段续（或动态）分配传输带宽，这样就可以大大提高通信线路的利用率，非常适合突发式的计算机数据。</p>
</blockquote>
<p><strong>分组交换网比较侧重于数据的传送，而不是为了打电话啥的，其能够连接不同类型的计算机，传输数据也十分可靠</strong>(这个时期也提出了<strong>TCP/IP协议的雏形</strong>)，但是缺点是<strong>没有形成统一的互连标准</strong>，使网络在规模与应用等方面受到了限制，因此也不利于普及。</p>
<p><img src="/2020/02/25/jisuanjiwangluo/2.jpg" alt="分组交换网"></p>
<ul>
<li><strong>第三阶段：面向标准化的计算机网络(20世纪70年代末到20世纪80年代初)</strong></li>
</ul>
<p>为了使不同体系结构的计算机网络都能互联，国际标准化组织ISO提出了一个能使各种计算机在世界范围内互联成网的标准框架—开放系统互连基本参考模型OSI.。这样，只要遵循OSI标准，一个系统就可以和位于世界上任何地方的、也遵循同一标准的其他任何系统进行通信。<br>1984年公布了 ISO7498，即ISO/OSI-RM国际标准，<strong>该模型按层次结构划分为七个子层，已被国际社会普遍接受，是目前计算机网络系统结构的基础(后面会讲解)</strong>。</p>
<p>但是在ARPANET的基础上，形成了<strong>以TCP/IP为核心的因特网</strong>。任何一台计算机只要遵循TCP/IP协议族标准，并有一个合法的IP地址，就可以接入到Internet。TCP和IP是Internet所采用的协议族中最核心的两个， 分别称为传输控制协议（Transmission Control Protocol, TCP）和互连网协议（Internet Protocol, IP）。</p>
<ul>
<li><strong>第四阶段：面向全球互连的计算机网络(二十世纪九十年代初至今)</strong></li>
</ul>
<blockquote>
<p>这一时期在计算机通信与网络技术方面以 高速率、高服务质量、高可靠性等为指标， 出现了高速以太网、VPN、无线网络、P2P网络、NGN等技术，计算机网络的发展与应用渗入了人们生活的各个方面，进入一个多层次的发展阶段。<br>各个国家都建立了自己的高速因特网，这些因特网的互连构成了全球互连的因特网，并且渗透到社会的各个层次。</p>
</blockquote>
<p>讲了这么久的历史，博主感到枯燥无味，也讲不下去了，如果大家还想深入了解，可以查询一下互联网的发展简史，可以看看咱们现在使用的互联网是怎么来的。</p>
<h2 id="计网的层次结构"><a href="#计网的层次结构" class="headerlink" title="计网的层次结构"></a>计网的层次结构</h2><p>1.层次结构设计的基本原则：</p>
<ul>
<li><p>各层之间相互独立：每一层都能够实现相对独立的功能，明确分工。</p>
</li>
<li><p>每一层要有足够的灵活性，可以应对未来的变化：比如说未来我们需要实现什么业务，这个时候可以把业务对应的功能放入到某个层当中，可以改变这些层的内容</p>
</li>
</ul>
<p>比如说，A和B通过一条数据通路相互连接，在这个连接的过程中，我们需要通过层次设计保证<strong>这条路要十分的顺畅，要能够识别目的计算机</strong>，即这条路到底是通向哪里，我们还可以通过这条路来了解<strong>目的计算机的状态是什么，以及这条路的数据会不会出现异常错误</strong>等等，通过层次设计我们还可以<strong>保证每一层都相对独立地执行本职工作，执行效率高</strong>。<br>我们以一个分层设计的模式为例：</p>
<table>
<thead>
<tr>
<th>分层</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>网络应用数据</td>
<td>实现视频，文件，游戏</td>
</tr>
<tr>
<td>数据可靠通信</td>
<td>查询数据错误或者重复</td>
</tr>
<tr>
<td>物理网络接入</td>
<td>光电物理特性</td>
</tr>
</tbody></table>
<p>等等</p>
<h3 id="层次结构下的两个模型"><a href="#层次结构下的两个模型" class="headerlink" title="层次结构下的两个模型"></a>层次结构下的两个模型</h3><p><strong>1.OSI七层模型：</strong></p>
<p><img src="/2020/02/25/jisuanjiwangluo/3.png" alt="OSI七层模型"></p>
<p>为了能够让大家看的更明白，博主从网上搬了一些讲的很形象的图片来做示例，加强理解，下面的表格是我的总结.</p>
<table>
<thead>
<tr>
<th>某一层</th>
<th>天生我层必有用</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为计算机用户提供接口和服务，这一层是我们所能够看见的，直接为我们服务</td>
</tr>
<tr>
<td>表示层</td>
<td>表示嘛就是表示数据的，这一层进行数据处理，比如说编码解码，加密解密等等</td>
</tr>
<tr>
<td>会话层</td>
<td>管理，建立，维护和重连通信会话，服务于通信，管理传输层以下的层</td>
</tr>
<tr>
<td>传输层</td>
<td>管理端到端的通信连接</td>
</tr>
<tr>
<td>网络层</td>
<td>通过数据路由决定路怎么走，决定它在网络中的路径</td>
</tr>
<tr>
<td>数据链路层</td>
<td>管理相邻节点之间的数据通信</td>
</tr>
<tr>
<td>物理层</td>
<td>数据通信的光电物理特性</td>
</tr>
</tbody></table>
<p>咦，这个时候是不是会感到奇怪，为什么感觉有些层的功能重复了，比如说会话层和应用层明明都是直接为客户服务的呀，咦，既然有这个模型，为什么我们现在的一般听到并且使用的模型却是TCP/IP模型呢，而不是这个说明OSI模型呢？别急，博主细细谈来：<br>可以说OSI是一个比较理论化的模型，当然，看起来是比较好，但是呢它在实际的市场化过程中却困难重重，最后以至于被TCP/IP模型给替代了。总共有三点致命的原因：</p>
<ul>
<li><p>OSI模型的设计专家缺乏实际经验，也就是说顾着搞科研而忽略了业务与科研的结合，忽略了科研的落地。</p>
</li>
<li><p>OSI标准模型制定的时间比较长，设备无法及时占领市场，其被TCP/IP模型抢先占领了市场。</p>
</li>
<li><p>OSI模型设计不是很合理，某些功能在多层中重复出现了。<br>因此就成为了TCP/IP模型的世界，那它又是个说明东西呢？<strong>看下面！！！</strong></p>
</li>
</ul>
<p><strong>2.TCP/IP四层模型：</strong><br>这个模型比OSI少了三层，总共有应用层，传输层，网络层以及网络接口层(也可以说是数据链路层)四层，但是每一层的功能都和OSI当中的一层或者几层的功能相似。如下表是它们之间的映射和每一层涉及到的协议，关于这些协议后面博主也会重点讲：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/4.png" alt="TCP/IP四层模型与OSI"></p>
<table>
<thead>
<tr>
<th>TCP层</th>
<th>每一层涉及的协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP,FTP协议</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP,UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>IP, ICMP协议，ARP,RARP协议</td>
</tr>
<tr>
<td>网络接口层</td>
<td>以太网协议</td>
</tr>
</tbody></table>
<p>比如说，A和B之间进行数据交换和通信的时候，这一整个过程就会涉及到这四层，它们之间会有一个”中介”，即路由，这个路由只需要用到网络层和网络接口层的功能。</p>
<h2 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h2><p>1.边缘部分：<br>以家庭为例，如下图：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/5.png" alt="家庭网络拓扑"></p>
<p>家庭当中的终端(比如说手机啊，电脑啊等等)，它们呢就会通过家里的路由器(WIFI)与外面进行数据通信，家里的路由就会连接我们那个地方，比如说镇上或者县里的网关，然后通过这个网关又和地方的ISP(网络服务提供商，就是我们现在听到的中国移动电信等等，地方ISP就是湖南移动，湖南电信啥的)进行通信，这仅仅只是边缘部分，至于之后会怎么样就是核心部分了，稍后讲。<br>再来看看企业的例子，如下图：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/6.png" alt="企业网络拓扑"></p>
<p>企业里的网络拓扑就比我们家庭里的要复杂些许，多了一些网关，企业内部的多个终端会和不同的路由进行通信(几个或数十个终端和一个路由通信)，然后每一个路由会连接到它们所对应的内部网关，然后这些网关都会汇合到一个统一网关上，再通过这个统一网关和地区ISP进行数据交互和通信。<br>至于后续如何，看看核心部分：</p>
<p>2.核心部分：这个部分主要是地区的ISP，主干ISP和国际ISP之间的通信了。</p>
<p><img src="/2020/02/25/jisuanjiwangluo/7.png" alt="核心部分"></p>
<p>每个地区的ISP都会集中和主干ISP进行数据交互(比如说湖南移动和中国移动总部通信)，当然如果说要翻墙和外国某个地方进行数据交互的话，那么这个主干ISP就会和其它国家的主干ISP进行通信，前提是它们都会经过国际路由，这个路由有啥用，后面讲？</p>
<p>3.二者结合来看：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/8.png" alt="互联网"></p>
<p>简单点看就是这样：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/9.png" alt="树状结构"></p>
<p>以上就是互联网的网络拓扑，相信大家也对计网有一定的了解了，或许有的读者还会疑惑，博主讲的好像也有点道理，可是我还不不太理解它们到底是什么通信的，地区ISP和地区ISP，终端和路由，它们是如何通信？凭什么就这样进行数据交互了？好，很好，带着问题阅读吧，答案在空中飘荡，飘荡着就在后面博主讲的地方去了。</p>
<h2 id="计网的性能指标"><a href="#计网的性能指标" class="headerlink" title="计网的性能指标"></a>计网的性能指标</h2><p>1.速率指标(就是我们所说的网速嘛)：速度指标的单位有Bps(1Bps = 1Byte/s),bps(1bps=1bit/s),Mbps(1Mbps=1Mbit/s)<br>为了能够有更好的理解，我们来看一个问题：比如说我们家如果拉了一个100M的光纤进行使用，可是当我们实际测速的时候，却只有12M/S，是不是这个商家在坑我们啊？不是的，算算就知道了，算完就长见识了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们这里所说的100M实际上就是100Mbps，而100Mbps&#x3D;100Mbit&#x2F;s&#x3D;(100&#x2F;8)MB&#x2F;s&#x3D;12.5MB&#x2F;s</span><br><span class="line">注意：1B&#x3D;8bit，所以我们测速的时候才是只有12M&#x2F;s。</span><br><span class="line">我靠，既然是12M&#x2F;s，为什么拉光纤的时候就不直接说速度12MB&#x2F;s，而是说100M呢？那是因为100看着就比12要大那么多，很吸引顾客，就好比我们平时看到的房价标注一样首付4万(实际上那个4万比首付两个字大得多，让人们误以为原来这房子只有四万啊，赚了，赶紧买)，博主开玩笑的，回归正途，继续讲。</span><br></pre></td></tr></table></figure>

<p>2.时延：时延=发送时延+排队时延+传播时延+处理时延</p>
<ul>
<li><p>发送时延=数据长度(bit)/发送速率(bit/s),也就是和网卡性能有关。</p>
</li>
<li><p>传播时延=传播路径距离/传播速率(bit/s)，这个主要和传输的介质有关，比如说光纤，铜线等等</p>
</li>
<li><p>排队时延=数据包在网络设备中等待被处理的时间，也就是说从它发送开始到被处理的那一瞬间所花的时间，不包括处理过程</p>
</li>
<li><p>处理时延=数据包到达设备或者目的机器中被处理的时间</p>
</li>
</ul>
<p>3.往返时间RTT：这个也是用来评估网络质量的，指的是数据报文在端到端通信当中来回一次的时间。咱们可以通过在CMD里面输入ping +某个目的设备的IP地址命令来查看这个RTT。<br>我就输入了： <code>ping 127.0.0.1</code>发一个数据报文给自己的机器看看这个RTT多少，发现为0ms</p>
<p><img src="/2020/02/25/jisuanjiwangluo/10.png" alt="示例"></p>
<h1 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>1.物理层是干嘛用的？</p>
<ul>
<li><p>物理层嘛，一看就是和实际线路相关的，用于连接不同的设备</p>
</li>
<li><p>在物理层中传输比特流，也就是数字信号(0和1高低电平交替表示)</p>
</li>
</ul>
<p>2.传输介质：有双绞线，同轴电缆，光纤，红外线，激光，WIFI等等(是不是觉得双绞线是啥鬼东西，不清楚，不清楚的话请打开百度查询双绞线，博主都把它给讲完了也太没意思了)</p>
<p><strong>3.信道：往一个方向传送信息的载体</strong>(一个通信电路包括发送信道和接收信道)<br>信道总共有三个分类，分别为单工通信信道，半双工通信信道，全双工通信信道。</p>
<table>
<thead>
<tr>
<th>信道种类</th>
<th>信道对应功能</th>
</tr>
</thead>
<tbody><tr>
<td>单工通信信道</td>
<td>只能够往一个方向通信，没有反方向的反馈，一去不复返</td>
</tr>
<tr>
<td>半双工通信信道</td>
<td>双方都可以发送接收信息，但是双方不能同时发送和接收</td>
</tr>
<tr>
<td>全双工通信信道</td>
<td>双方可以同时发送接收信息</td>
</tr>
</tbody></table>
<p>3.分用-复用技术：提升信道利用率<br><img src="/2020/02/25/jisuanjiwangluo/11.png" alt="分用-复用技术"><br>多个机器设备和复用器，分用器连接，分用器和复用器之间通过信道通信，这样就可以大大减少信道的使用量，提供利用效率(稍作了解即可)<br>一般会使用一下几种技术：</p>
<ul>
<li><p>频分复用</p>
</li>
<li><p>时分复用</p>
</li>
<li><p>波分复用</p>
</li>
<li><p>码分复用</p>
</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>1.封装成帧：</p>
<ul>
<li><p>“帧”是数据链路层数据的基本单位</p>
</li>
<li><p>发送端在网络层的一段数据前后添加特定的标记形成“帧”</p>
</li>
<li><p>接收段根据前后特定的标记识别出“帧”数据<br><strong>注意！！！帧数据的首部标记和尾部标记都是特定的控制字符(特定的比特流)</strong>，比如说首部标记叫做SOH，其特定的比特流为：00000001，而尾部标记为EOT，其特定的比特流为：00000100.<br>看到这里，或许有的人会很奇怪，如果说我中间的帧数据当中恰好就出现了SOH或者EOT咋办呢，这样会不会造成数据异常呢，好，对于这个问题，我们看到它的另外一个特点，透明传输：</p>
</li>
</ul>
<p>2.透明传输：如果说控制字符出现在帧数据当中，就要把它当作不存在去处理。<br><strong>如何去实现不存在的处理？</strong><br>假如说帧数据当中出现了特定的尾部标记EOT，不进行特殊处理的话，系统会误以为这是尾部标记，其之前的数据有效，后面的就会不管，这个时候得作出处理，我们得在数据中的控制字符前作特殊处理，在这些特殊字符前面加上ESC转义字符，当我们的系统在EOT前面发现了ESC转义字符，就会把它进行透明处理，直接忽视。<br>当然，有的人还会疑惑，如果中间的数据出现了转义字符咋办，别慌，继续作特殊处理，在转义字符前面加上转义字符即可。</p>
<p>3.差错检测：物理层只管着传输比特流，却无法检查传输数据是否出错，这个时候的工作就交给数据链路层来做了，其负责差错检测。怎么检测，下回分解！！</p>
<h2 id="数据链路层的差错检测"><a href="#数据链路层的差错检测" class="headerlink" title="数据链路层的差错检测"></a>数据链路层的差错检测</h2><p>1.奇偶校验码：这个比较是一个比较简单的检测数据差错的方法，咱们来看看一个例子就懂了。<br>假设传输的数据为：00110010，那么我们就会在实际传输的时候，在后面加上奇偶校验码1，即数据为：001100101(因为前面有奇数个1)，若数据为00111010，则加入奇偶校验码以后数据为：001110100(前面有偶数个1)</p>
<p><strong>这种方法还比较简单，但是大家可以发现，这个只能检测一位数据出错的情况，若出错两位数据或者多位，就难以检测了</strong></p>
<p><strong>2.循环冗余校验码CRC：</strong>根据传输或者保存的数据而产生固定位数校验码，它会检测数据传输或者保存后可能出现的错误，把生成的数字计算出来并且附加到数据后面。<br>或许，看到这，还是不太清楚，来看例子就欧克了。<br>咱们得先了解一下<strong>模2除法(模2除法实际上是除最高位以外的位之间的异或运算)：</strong><br>比如说1001与1010进行模2除法，1001的最高位为1，因此商为1，而除最高位以外的其它为进行异或运算，得到的余数为011.</p>
<p><strong>其运算步骤为：</strong></p>
<ul>
<li><p>先选定一个用于校验的多项式G(x),并且在数据尾部添加r个0(r为G(x)中的最高阶)</p>
</li>
<li><p>将添加的r个0后的新数据使用模2除法除以多项式的位串(比如说G(x)=x^2+x+1=1<em>x^2+1</em>x^1+1*x^0,那么G(X)的位串为111，最高阶为2，其中位串和每一项的系数和阶数有关，阶数大的位数大)</p>
</li>
<li><p>得到的余数填充在原数据r个0的为止，若余数位数不够，则高位补0，最后得到可校验位位串</p>
</li>
</ul>
<p><strong>我们来看个简单的例子：</strong><br>我们运用CRC来计算101001的可校验位串(设G(x)=x^3+x^2+1)：</p>
<ul>
<li><p>得到G(x)的二进制位串为1101，最高阶为3，因此填充3个0到101001后的新数据为101001000</p>
</li>
<li><p>新数据101001000对位串1101进行模2除法，以下图是具体过程：</p>
</li>
</ul>
<p><img src="/2020/02/25/jisuanjiwangluo/12.png" alt="模2除法过程"></p>
<p>在这个过程中，当我们进行进行每一步的模2除法时，如果最高位为1，则得到的商为1，比如说第一步的模2除法为1010对1101进行模2除法，最高位为1，因此商的最高(最左边)位为1，而其它位进行异或运算，因此第一步之后的结果为111，把后面的一位0拿过来变成1110，由于最高位为1，继续对1101进行模2除法，规则按照上述来，如果说进行模2除法的时候，最高位为0，那么商为0，并且此时不是对1101，而是对0000进行模2除法，以此类推得到最后的结果，我们可以看到余数为001，以此替换原数据后面的三个0，得到最后的可校验位串为101001001.</p>
<ul>
<li>进行完模2除法以后，再进行检验，将接收端得到的数据除以G(X)的位串，根据余数来判断对错，如果说余数为0，则说明这个数据传输或者保存的时候没有出错，反之则出错。</li>
</ul>
<p>3.CRC的相关说明：</p>
<ul>
<li><p>CRC的错误检测能力和位串的阶数r有关，阶数越高检测的精度准确率越高</p>
</li>
<li><p>数据链路层只进行数据检测，不会进行纠正，如果说检测到的数据出现错误，则把它丢掉</p>
</li>
<li><p>G(X)有特定的选择，不是随机的，不同的用途和行业会使用不同的G(X)。</p>
</li>
</ul>
<p><img src="/2020/02/25/jisuanjiwangluo/13.png" alt="常用G(x)表达式"></p>
<h2 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h2><p>1.MTU：最大传输单元，用来描述最大的能够传输的数据帧，可以说数据帧的长度受MTU的限制。</p>
<p>2.路径MTU：由链路当中MTU的最小值决定。比如说A到B的MTU为1164，B到C的MTU为1000，那么这三个的路径MTU为1000.</p>
<h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>来学习这个知识点之前，咱们先看一个例子，比如说A要发数据给B，但是这个过程的经过路由器，路由器是怎么知道A要发给B的，带着这个问题来阅读博客吧。<br>1.MAC地址：其也可以说是物理地址或者硬件地址</p>
<ul>
<li><p>每一个设备都有一个唯一的MAC地址</p>
</li>
<li><p>MAC地址总共有48位，一般使用16进制来表示，比如说30-B4-9E-ED-85-CA,每个占四个比特位，总共有12个，因此有48位。</p>
</li>
<li><p>查看MAC地址一般是输入命令<code>ipconfig /all</code>，输入以后，会出现下面的一大堆看不懂的东西，看到那个物理地址就是某一个设备的MAC地址</p>
</li>
</ul>
<p><img src="/2020/02/25/jisuanjiwangluo/14.png" alt="MAC"></p>
<p>2.以太网协议：完成相邻设备的数据帧传输，应用于数据链路层。</p>
<ul>
<li>首先咱们得了解以太网数据是什么，以下是以太网数据的格式</li>
</ul>
<table>
<thead>
<tr>
<th>目的MAC地址</th>
<th>源MAC地址</th>
<th>类型</th>
<th>帧数据</th>
<th>CRC</th>
</tr>
</thead>
<tbody><tr>
<td>6个字节</td>
<td>6个字节</td>
<td>2个字节</td>
<td>46-1500字节</td>
<td>4字节</td>
</tr>
</tbody></table>
<p>其中目的和源MAC地址是用来寻找设备的，类型代表的是帧数据当中具体是什么协议的数据，帧数据就是具体内容了，CRC就是用来检测差错的，即循环冗余校验码。</p>
<ul>
<li>要了解数据链路层的工作原理，我们还得知道MAC地址表(直接映射到硬件接口)，以下是它的格式：</li>
</ul>
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>硬件接口</th>
</tr>
</thead>
<tbody><tr>
<td>某个设备的MAC地址</td>
<td>对应某个设备的接口，一般都在路由中</td>
</tr>
</tbody></table>
<p><strong>3.网络接口层中数据链路层的具体流程：</strong><br>我们看一个例子：<br>比如说A要发送数据给设备B或者C，但是它们之间得经过路由，在这个发送数据的过程中：</p>
<ul>
<li><p>A通过网卡发送数据帧，数据帧到达路由器</p>
</li>
<li><p>路由器取出数据帧的前6个字节(目的MAC地址)，然后匹配路由当中存储的MAC地址表，找到对应的网络接口，比如说发现这个网络接口位设备B</p>
</li>
<li><p>路由器会往该网络接口对应的设备B中发送数据帧<br>这是一般的过程，当然如果说在匹配MAC地址表的时候，发现没有目的的MAC地址和网络接口映射，这个时候，路由器会广播A的数据帧到除A以外的所有端口，E将会收到B,C的回应，并且把B,C的MAC地址记录到MAC地址表当中，之后再进行匹配发送数据。</p>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>1.虚拟互联网络：设备A与设备B相连，进行数据通信，需要经过虚拟互联网络</p>
<ul>
<li>IP协议使得复杂的实际网络变为一个虚拟互连的网络</li>
<li>IP协议使得网络层能够屏蔽底层细节而专注于数据转发</li>
<li>IP协议解决了虚拟网络中数据报传输路径的问题</li>
</ul>
<p>2.IP协议：</p>
<ul>
<li>MAC地址与IP地址的对比：</li>
</ul>
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>占48位字，是每一个网络设备唯一的通行证，不可以改变，一般使用十六进制表示</td>
<td>占32位字，也就是32个比特网，是每一个网络设备的标识，但是其随着网络环境的变化而改变，一般使用点分十进制表示，比如说127.0.0.1</td>
</tr>
</tbody></table>
<ul>
<li><p>IP数据报：由IP首部和IP数据报数据组成(单位位比特位)</p>
<p><img src="/2020/02/25/jisuanjiwangluo/15.png" alt="IP数据报格式"></p>
<p>其中除IP数据以外都是IP首部的内容，以下是我对这些内容的总结：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>IP首部内容</th>
<th>各个部分的功能</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>占4位字，即四个比特位，指的是IP协议的版本(通信双方的版本必须一致)，当前主流版本为IPV4，当然以后IPV6也会逐渐普及</td>
</tr>
<tr>
<td>首部长度</td>
<td>占4位字，最大数值为15，表示的是IP首部的长度，其单位为4个字节，也就是说一个首部长度相当于4个字节</td>
</tr>
<tr>
<td>服务类型</td>
<td>占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。只有在使用区分服务时，这个字段才起作用。</td>
</tr>
<tr>
<td>总长度</td>
<td>占16位，最大数值位65535，表示的是IP数据报总长度</td>
</tr>
<tr>
<td>标识</td>
<td>占16位，区分不同IP数据报</td>
</tr>
<tr>
<td>标志</td>
<td>占3位，判断IP报文是否需要分片</td>
</tr>
<tr>
<td>片偏移</td>
<td>如果说总长度大于最大传输单元MTU，那么就会将其拆分为多个数据帧，这个记录的是当前数据帧保存的是第几个偏移的IP数据</td>
</tr>
<tr>
<td>生存时间TTL</td>
<td>占8位，IP数据报文在网络当中的寿命，每经过一个设备，就会减一，当TTL为0的时候，数据报会被丢弃，这也是为了避免IP报文在网络当中找不到归宿的时候，避免其无限传输，而占用网络带宽，浪费资源</td>
</tr>
<tr>
<td>协议</td>
<td>占8位，表示IP数据报所携带的具体数据是什么协议，比如说这个字段值为1的时候表示ICMP协议等等</td>
</tr>
<tr>
<td>首部校验和</td>
<td>占16位，校验IP首部是否会出错</td>
</tr>
<tr>
<td>源IP地址</td>
<td>发送IP数据报设备的IP地址</td>
</tr>
<tr>
<td>目的IP地址</td>
<td>最终接收IP数据设备的IP地址</td>
</tr>
<tr>
<td>选项</td>
<td>IP头部其他内容，可以不用</td>
</tr>
</tbody></table>
<h2 id="IP协议的转发流程"><a href="#IP协议的转发流程" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h2><p>1.路由表的简介：由目的IP地址和下一跳IP地址组成：</p>
<table>
<thead>
<tr>
<th>目的IP地址</th>
<th>下一跳IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>IP1</td>
<td>IP2</td>
</tr>
<tr>
<td>。。。</td>
<td>。。。</td>
</tr>
</tbody></table>
<p>比如说第一个表示的就是这个数据报最终的归宿在IP1的设备，当前要去的下一个地方就是IP2的设备，也就是下一跳。</p>
<p>2.IP协议的转发流程</p>
<p><img src="/2020/02/25/jisuanjiwangluo/16.png" alt="IP协议转发流程"></p>
<p>比如说A发送数据报给C，那么我们来分析一下这个流程，以网络层为例：</p>
<ul>
<li>A发出目的地为C的IP数据报，并且查询本地路由表，发现目的C对应的下一跳的IP地址为E</li>
<li>A把数据报发送给E</li>
<li>E查询本地路由表发现下一跳为F，把数据表发送给F</li>
<li>F查询本地路由表发现目的C就在前面，与它相连，因此发送数据给C，结束</li>
</ul>
<p><strong>接下来我们把网络层和网络接口层结合起来看看：</strong></p>
<ul>
<li>A发出目的地为C的IP数据报，查询本地路由表发现下一跳IP地址为E</li>
<li>A将IP数据报交给数据链路层，并且告知目的MAC地址为E</li>
<li>数据链路层填充源MAC地址和目的MAC地址</li>
<li>数据链路层通过物理层将数据发给E</li>
<li>E的数据链路层收到数据帧，把帧数据再交给网络层</li>
<li>E继续查询本地路由表，然后巴拉巴拉，以此类推，最终数据发给了C</li>
</ul>
<p><strong>我们可以发现，在这个过程中，数据帧每一跳的MAC地址都在改变，因为告知目的MAC地址一直在变，但是IP数据报每一跳的IP地址不变，因为目的IP地址没变，本地路由表也没变</strong></p>
<h2 id="ARP协议与RARP协议"><a href="#ARP协议与RARP协议" class="headerlink" title="ARP协议与RARP协议"></a>ARP协议与RARP协议</h2><p>1.ARP协议：又称为地址解析协议，即把网络层32为IP地址通过ARP协议转换成对应的数据链路层48位MAC地址，在这个过程会使用到ARP缓存表：</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>MAC地址</th>
</tr>
</thead>
<tbody><tr>
<td>IP1</td>
<td>MAC1</td>
</tr>
</tbody></table>
<p>这个其实就是IP与MAC之间的映射</p>
<p>如果说在进行映射查询的时候，发现没有对应需要的IP地址和MAC地址的映射，那么就会把设备该信息广播到其他设备，如果说对应设备发现自己是“所谓伊人”，那么它就会发出回应，然后设备就会在ARP缓存表中记录当前设备的MAC地址和IP地址的映射。</p>
<p><strong>注意！！！ARP缓存表并不是永久有效的，而是有一定期限，因为IP地址会随着网络环境而变化，而MAC地址不变，因此映射关系很容易改变，本地ARP缓存表也会做出相关改变</strong></p>
<p>如果说，我们要查询自己本机的ARP缓存表，可以打开你的CMD，然后输入<code>arp -a</code> 之后我们就可以看到我们需要的东西了。</p>
<p>2.ARP协议对应的位置：</p>
<p>ARP协议的数据封装在数据帧当中，当数据帧中的类型位0806的时候，就表示是携带了ARP协议的数据(一般为28位字节)，ARP协议具体数据格式为：</p>
<table>
<thead>
<tr>
<th>硬件类型</th>
<th>协议类型</th>
<th>标记</th>
<th>发送端以太网地址</th>
<th>发送端IP地址</th>
<th>目的端以太网地址</th>
<th>目的地IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>占2位字节</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
</tr>
</tbody></table>
<p>2.RARP协议：也称为逆地址解析协议，也就是由MAC转IP的(类型为8035)</p>
<p>至于具体内容和ARP类似，可以类比，这两种协议在IP协议的转发流程中是一起使用的，把数据交给网络层(ARP),网络层数据交给数据链路层(RARP)</p>
<h2 id="IP地址的子网划分"><a href="#IP地址的子网划分" class="headerlink" title="IP地址的子网划分"></a>IP地址的子网划分</h2><p>1.分类的IP地址：IP地址分为网络号和主机号，根据网络号位数的不同可以分为A,B,C三种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>A类地址</td>
<td>网络号占8位(以0开头)，主机号占24位字</td>
</tr>
<tr>
<td>B类地址</td>
<td>网络号占16位(以10开头)，主机号占16位</td>
</tr>
<tr>
<td>C类地址</td>
<td>网络号占24位(以110开头)，主机号占8位</td>
</tr>
</tbody></table>
<p><strong>特别注意！！！</strong></p>
<ul>
<li><p>特殊的主机号：</p>
<ul>
<li>主机号全为0表示当前网络段，不可以分配到主机</li>
<li>主机号全为1表示广播地址，向当前网络段的所有主机发送信息</li>
</ul>
</li>
<li><p>特殊的网络号：</p>
<ul>
<li>A类地址网络段全为0表示特殊网络，不可用</li>
<li>A类地址网络段后七位全为1表示回环地址，比如说127.0.0.1表示的是本机回环地址，不属于任何类别，代表的是本机的虚拟接口(127的二进制表示位01111111，以0开头，并且后七位为1，因此为特殊网络号)</li>
<li>B类地址网络号后14位全为0不可使用</li>
<li>C类地址网络号后21位全为0不可使用</li>
</ul>
</li>
</ul>
<p>看完特殊的网络号和主机号以后，我们来做一个总结：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>最小网络号</th>
<th>最大网络号</th>
<th>子网数量</th>
<th>最小主机号</th>
<th>最大主机号</th>
<th>主机数量</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1</td>
<td>127</td>
<td>2^7-2(把两个特殊的网络号去掉)</td>
<td>0.0.1</td>
<td>255.255.254(主机号不可全为1)</td>
<td>2^24-2</td>
</tr>
<tr>
<td>B</td>
<td>128.1</td>
<td>191.255</td>
<td>2^14-1</td>
<td>0.1</td>
<td>255.254</td>
<td>2^16-2</td>
</tr>
<tr>
<td>C</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>2^21-1</td>
<td>1</td>
<td>254</td>
<td>2^8-2</td>
</tr>
</tbody></table>
<p>2.划分子网()避免IP地址的浪费：一般分为网络号+子网号+主机号</p>
<p>比如说对于C类地址网络段为193.10.10的可以划分两个子网(根据第一位主机号为0或1)，第一个子网范围为：193.10.10.0<del>193.10.10.127， 第二个子网范围为：193.10.10.128</del>193.10.10.254</p>
<p><strong>问题来了！那我们如何在子网号这么多的情况下来判断这个IP地址到底属于哪个网络段</strong></p>
<p>比如说，对于IP地址为193.10.10.6，我们来找出它的子网：</p>
<ul>
<li><p>首先我们得了解子网掩码(这个过程需要用到)，子网掩码就是由连续的0和1组成，比如说A类地址的某个子网掩码为：255.0.0.0,B类地址的子网掩码为：255.255.0.0，C类地址的子网掩码为255.255.255.0。</p>
</li>
<li><p>我们先求出这个IP地址的二进制表达形式：11000001.00001010.00001010.00000110以及它的子网掩码(一看就是C类)为11111111.11111111.11111111.00000000</p>
</li>
<li><p>然后让子网掩码和IP地址的二进制表达形式进行位与位之间的与运算，最后得到结果之后，再用点分十进制表示，因此求得其子网号为：193.10.10.0</p>
</li>
</ul>
<p>3.无分类编址CIDR(目前使用最广泛的)：</p>
<p>1.说明：</p>
<ul>
<li><p>CIDR中没有什么A,B,C类这几个不同类别的网络号，以及子网</p>
</li>
<li><p>其网络前缀相同的IP地址称为一个CIDR地址块：网络前缀(位数任意)+主机号</p>
</li>
<li><p>对于CIDR，我们一般使用斜线记法,比如说193.10.10.129/25表示的是网络前缀有25位。</p>
</li>
<li><p>虽然说CIDR没有A,B,C这几类，但是子网掩码，特殊网络号、主机号都是一样的。</p>
</li>
</ul>
<p>例如下：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/17.png" alt="CIDR"></p>
<p>对于使用数量比较大的，例如说中型网络和大型网络，我们分配的网络前缀就少些，以配置更多的主机号，反之则多。</p>
<h2 id="网络地址转NAT技术"><a href="#网络地址转NAT技术" class="headerlink" title="网络地址转NAT技术"></a>网络地址转NAT技术</h2><p>1.背景：由于IPV4不够用了，按理来说是够的，不过早期对于IPV4规划不合理，就造成了大量的浪费，因此就产生了网络地址转NAT技术以弥补这个问题</p>
<p>2.IP地址分类：</p>
<ul>
<li>内网地址：内部机构使用，不过要避免与外网重复</li>
<li>外网地址：全球范围使用，外网也可以是公网，是唯一的。</li>
</ul>
<p>NAT技术就涉及内网与外网的通信。</p>
<p>3.说明：</p>
<ul>
<li>不同的公司使用同样的内网地址是不冲突的</li>
<li>NAT技术用于多个主机通过一个公有IP访问互联网</li>
<li>端口号：指定某个设备具体哪个进程在使用网络，在通信</li>
</ul>
<p>4.具体过程：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/18.png" alt="NAT"></p>
<p>这个过程同样的也会用到一个表：NAT表</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>旧地址及端口号</th>
<th>新地址及端口号</th>
</tr>
</thead>
<tbody><tr>
<td>出</td>
<td>192.168.2.11：6666</td>
<td>173.21.59.10：1666</td>
</tr>
<tr>
<td>出</td>
<td>192.168.2.10：7777</td>
<td>173.21.59.10：1777</td>
</tr>
<tr>
<td>入</td>
<td>173.21.59.10：1666</td>
<td>192.168.2.11：6666</td>
</tr>
<tr>
<td>入</td>
<td>173.21.59.10：1777</td>
<td>192.168.2.10：7777</td>
</tr>
</tbody></table>
<p>过程：IP地址为192.168.2.11的设备中端口为6666的进程使用网络，发出IP数据报文以后的对于源地址也是这个，当IP报文来到路由器的时候，其会根据NAT表把旧地址及端口号替换为新地址及端口号(173.21.59.10：1666)，数据会以新地址及端口号发送到外部网络中进行通信，目的设备会识别其新的地址及端口号，处理完数据请求以后，发送应答数据给路由器，然后再把新地址及端口号通过查询NAT表来替换为旧地址及端口号(192.168.2.11)，然后设备会收到应答数据报文。</p>
<p>在这个过程中，NAT技术会把不同IP地址及端口号转换到公有的IP及端口号与外网通信，减缓了IP地址的消耗，但是增加了复杂度。</p>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>1.概述：其也称为网际控制报文协议，用来辅助IP协议的，可以报告错误信息或者异常情况</p>
<p>2.位置及组成：</p>
<ul>
<li>其数据封装在IP报文数据当中</li>
<li>由ICMP报文首部和ICMP报文数据组成</li>
</ul>
<p>3.ICMP首部：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代码</th>
<th>校验和</th>
</tr>
</thead>
<tbody><tr>
<td>8个比特位</td>
<td>8位</td>
<td>16位</td>
</tr>
</tbody></table>
<p>ICMP协议封装在IP协议当中，IP首部的8位协议会会写入字段值为1，来表示封装的数据是ICMP协议</p>
<p>对于类型和代码或许大家会很疑惑，其实ICMP报文的类型总共有两种，分别为差错报告报文和询问报告报文：</p>
<ul>
<li>差错报告报文：</li>
</ul>
<table>
<thead>
<tr>
<th>类型的值</th>
<th>报文类型</th>
<th>具体代码</th>
</tr>
</thead>
<tbody><tr>
<td>3(终点不可达)</td>
<td>分为网络不可达和主机不可达(就是说这个地方是不能够去的)</td>
<td>网络不可达代码表示为0，主机不可达为1</td>
</tr>
<tr>
<td>5(重定向)</td>
<td>网络重定向和主机重定向(就是说这个目的地需要重新定向，比如说换一个网络，换一个主机)</td>
<td>前者代码为0，后者为1</td>
</tr>
<tr>
<td>11</td>
<td>传输超时</td>
<td>-</td>
</tr>
<tr>
<td>12(IP数据出现问题)</td>
<td>坏的IP头(IP头部出问题)和缺少其它必要参数</td>
<td>分别为0和1</td>
</tr>
</tbody></table>
<ul>
<li>询问报文：</li>
</ul>
<table>
<thead>
<tr>
<th>类型的值</th>
<th>报文类型</th>
<th>具体代码</th>
</tr>
</thead>
<tbody><tr>
<td>0或8</td>
<td>回送请求或者应答(验证网络是否已经连通)</td>
<td>—-</td>
</tr>
<tr>
<td>13或14</td>
<td>时间戳请求或者应答(通信请求时间同步)</td>
<td>—</td>
</tr>
</tbody></table>
<h2 id="ICMP协议的应用"><a href="#ICMP协议的应用" class="headerlink" title="ICMP协议的应用"></a>ICMP协议的应用</h2><p>1.ping应用(询问报文)：这个一般是用来检查网络故障的</p>
<ul>
<li>检查自己的主机网络问题：ping+回环地址，比如说ping 127.0.0.1就是检查自己主机的问题</li>
<li>检查网关问题，是否连接上：ping+网关地址</li>
<li>检查和ISP或者目的设备连接问题：ping+远端地址</li>
</ul>
<p>2.Traceroute应用：探测IP数据报在网络中走过的路径(利用差错不可达和TTL)，如果说TTL=0，则记录为不可达，发出ICMP终点不可达报文。</p>
<p><strong>举个例子：*</strong></p>
<p>A——-。。。。。——-&gt;B</p>
<p>从设备A到设备B的过程中，我们若要获取这个过程的网络路径，我们则要先A中的Traceroute封装一个TTL=1的报文，经过第一个网络设备之后，TTL减为0，此时当前网络设备发送一个ICMP不可达报文给A，A就会记录当前的IP地址，之后A再会封装一个TTL为2的报文，然后经过第二个网络，TTL减为0，之后。。。以此类推，直到到达目的地为止，这样就可以记录路径了。</p>
<p>我们可以在我们自己的CMD中输入：<code>tracert www.baidu.com</code> 当然，也可以是其它网址或者IP地址，这个时候我们就可以看到访问的具体路径了。</p>
<p><img src="/2020/02/25/jisuanjiwangluo/19.png" alt="ROAD"></p>
<h2 id="网络层的路由概述"><a href="#网络层的路由概述" class="headerlink" title="网络层的路由概述"></a>网络层的路由概述</h2><p>1.路由表需要解决什么问题？</p>
<ul>
<li>下一跳的地址是怎么来的？</li>
<li>下一跳的地址是唯一的吗？</li>
<li>下一跳的地址是最佳的吗？</li>
<li>路由器这么多，它们又是如何协调好的？</li>
</ul>
<p>互联网又这么大并且复杂，因此需要把互联网化成很多个部分来管理，就像一个国家划成很多个省，很多个市，县等等，也是为了更好的管理，更高的效率。</p>
<p>2.为了解决上面的问题，因此又出现了各种路由算法：必须满足：</p>
<ul>
<li>正确性，完整性</li>
<li>简单性</li>
<li>可变通性</li>
<li>稳定性，公平性</li>
</ul>
<p>3.自治系统(AS)：处于一个管理机构下的网络设备群，其中AS内部的网络自行管理，其对外提供一个或者多个接口。</p>
<p>4.自治系统内部路由的协议：内部网关协议(RIP和OSPF)</p>
<p>5.自治系统外部路由的协议：外部网关协议(BGP)</p>
<h2 id="内部网关路由协议"><a href="#内部网关路由协议" class="headerlink" title="内部网关路由协议"></a>内部网关路由协议</h2><h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><p>1.距离矢量算法(DV):</p>
<ul>
<li>每一个节点使用两个向量Di和Si表示，其中Di表示当前节点到别的节点的距离，Si表示当前节点到别的节点的下一个节点(下一跳)</li>
<li>每一个节点到与相邻节点交换变量信息Di和Si(交换)</li>
<li>每一个节点根据交换的信息更新自己的节点信息(更新)</li>
</ul>
<p><strong>驰哥来解释：</strong></p>
<p>Di={di1，di2，….,din}，Si={si1，si2，…,sin}，其中din表示第i个节点到第n个节点的距离，sin表示第i个节点到第n个节点的下一个节点，n表示节点数量。</p>
<p>并且dij=min(dix+dxj)，取的是路径的最小值。</p>
<p>我们来举个例子，看到一个图，把网络当成图来看，节点就为各个设备，线就代表路径：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/20.png" alt="DV"></p>
<p>以A为例，一步步来更新A的DV表，我们假设，初始化的时候，其DV是这样的：对于与路径相关的Di信息是这样的</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>11</td>
</tr>
<tr>
<td>C</td>
<td>12</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
</tr>
<tr>
<td>E</td>
<td>21</td>
</tr>
<tr>
<td>F</td>
<td>17</td>
</tr>
</tbody></table>
<p>对于Si的信息暂时还不知道：</p>
<p>而根据通信，可以获得与A直接相连的节点的距离，即AB=6,AC=9,AD=8,AF=7。</p>
<p>并且可以收到相邻各个节点的D的信息，合并可以得到一个初始化的关于A与其各个相邻节点D信息的总表：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/21.png" alt="总表"></p>
<p>现在，我们来一步步交换更新信息：</p>
<ul>
<li><p>A与B交换矢量信息: daa=0,dab=min{11(原来的),6(与B交换信息后得知的)}=6，dac={12,6+11(A-&gt;B-&gt;C)}=12,dad=min{10,6+7(A-&gt;B-&gt;D)}=10,dae={21,6+17}=21,daf={17,6+11}=17.</p>
<p>更新完毕，得到新表，并且可以得到最新的关于A的S信息(基于上述的最短距离更新)：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>A</td>
</tr>
<tr>
<td>B</td>
<td>B</td>
</tr>
<tr>
<td>C</td>
<td>-</td>
</tr>
<tr>
<td>D</td>
<td>-</td>
</tr>
<tr>
<td>E</td>
<td>-</td>
</tr>
<tr>
<td>F</td>
<td>-</td>
</tr>
</tbody></table>
<p>  (由于更新基本没变，就更新了A-&gt;B，因此A到B节点的下一节点就为B，其他的未知)</p>
<p>  以此类推不断更新，经过与各个相邻节点交换信息之后，得到最终A的D向量和S向量的表：</p>
<table>
<thead>
<tr>
<th>D向量</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>6</td>
</tr>
<tr>
<td>C</td>
<td>9</td>
</tr>
<tr>
<td>D</td>
<td>8</td>
</tr>
<tr>
<td>E</td>
<td>19</td>
</tr>
<tr>
<td>F</td>
<td>7</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>S向量</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>A</td>
</tr>
<tr>
<td>B</td>
<td>B</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>D</td>
<td>D</td>
</tr>
<tr>
<td>E</td>
<td>D</td>
</tr>
<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody></table>
<p>2.RIP协议的过程(使用了DV算法)：</p>
<ul>
<li>RIP协议会把网络的跳数作为DV算法的路径</li>
<li>RIP协议每隔30秒就会交换一次路由信息</li>
<li>如果跳数大于15的路由是不可达路由</li>
</ul>
<p><strong>过程：</strong></p>
<ul>
<li><p>路由器初始化路由信息(即Di和Si)</p>
</li>
<li><p>对相邻路由x发过来的信息，对信息内容进行修改(假设下一跳地址设置为X，更新表时，距离+1)</p>
<ul>
<li>检索本地路由，将信息中的新路由插入到路由表当中，信息可能是路由表当中没有的(没有的肯定拿进来)</li>
<li>检索本地路由，对于下一跳位X的更新为修改后的信息(暂时更新，以便于和原表对比)</li>
<li>检索本地路由，对比相同目的的距离，如果新信息的距离更小，则更新本地路由信息(用DV算法找最优的，新表和原表对比)</li>
</ul>
</li>
<li><p>如果三分钟内没有收到相邻的路由信息，则把相邻路由设置为不可达，以后就不管他了，不从它这过。</p>
</li>
</ul>
<p>这个就是RIP协议的过程，我们来分析它的优缺点：</p>
<p>优点当然就是比较简单，开销小，管好隔壁就可以了</p>
<p>缺点就是故障信息传递很慢，因为太相信隔壁老刘了，隔壁老刘可能告诉你的不对，你也相信它，或者隔壁老刘告诉你的是个笨方法，根本到不了你要去的地方，你还是傻傻地会去相信。这个也会限制网络规模，因为都是和相邻节点通信并且交换信息，如果说规模是那种很大的，速度就会比较慢，就不适用了。</p>
<h3 id="Dijkstra算法-求最短路径"><a href="#Dijkstra算法-求最短路径" class="headerlink" title="Dijkstra算法(求最短路径)"></a>Dijkstra算法(求最短路径)</h3><p>1.特点：</p>
<ul>
<li>是一种图的算法</li>
<li>解决了有权图一个节点到其它节点的最小距离</li>
<li>以起始点为中心，向外层层扩展</li>
</ul>
<p>2.过程：</p>
<ul>
<li>初始化两个集合S和U，S只有初始顶点，U是其它顶点的集合。</li>
<li>如果说U不为空，那么就对A到U集合顶点的距离进行排序，选取距离A最近的一个顶点D(中间也可以有其它顶点，比如说A-&gt;B-C)，将该顶点放入到S中，重复该步骤，直到U为空.</li>
</ul>
<h3 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h3><p>1.链路状态协议(LS协议)：</p>
<ul>
<li>向所有的路由器发送消息，一传十，十传百</li>
<li>消息描述了该路由器和相邻路由器的链路状态(比如说距离，时延等等)，这个链路状态主要由网络管理人员决定</li>
<li>只有当链路状态发送变化的时候，才能够发送信息</li>
</ul>
<p><strong>2.OSPF协议</strong>：开放最短路径优先，利用了Dijkstra算法</p>
<ul>
<li>向所有路由发送消息，每一个路由获取网络中的消息，得到网络完整的拓扑，这些信息也称为链路状态数据库。</li>
</ul>
<p>后面就是和链路状态协议的步骤一样。</p>
<p>这个协议比RIP协议更加的客观先进，因为路径选择标准不再是单一的距离，而是链路状态(距离，时延等等)多种因素，而且这个不是固定的实践就会进行数据交换，而且等链路状态发送变化的时候才会发送消息，更加容易收敛，发现问题故障。</p>
<p>3.五种消息类型：这个协议涉及到五种类型的消息</p>
<ul>
<li>问候消息：与相邻路由器通信，看看是否可达</li>
<li>链路状态数据库描述消息：向相邻路由器发送自己的链路状态消息</li>
<li>链路状态请求消息：向相邻路由器发送链路状态获取请求</li>
<li>链路状态更新信息：更新链路状态</li>
<li>链路状态确认信息：确认更新</li>
</ul>
<p>4.过程：</p>
<p>路由器接入网络-&gt;路由向邻居发送问候消息-&gt;与邻居交流链路状态数据库-&gt;广播和更新</p>
<p>5.对比：</p>
<table>
<thead>
<tr>
<th>RIP</th>
<th>OSPF</th>
</tr>
</thead>
<tbody><tr>
<td>从邻居看网络，距离是累加的，操作比较频繁，收敛比较慢，信息是通过路由间拷贝更新的</td>
<td>可以获取整个网络拓扑，使用Dijkstra算法计算最短路径，状态变化才更新，收敛更快，通过路由间传递链路状态信息，更加先进</td>
</tr>
</tbody></table>
<h2 id="外部网关路由协议之BGP协议"><a href="#外部网关路由协议之BGP协议" class="headerlink" title="外部网关路由协议之BGP协议"></a>外部网关路由协议之BGP协议</h2><p>1.概述：BGP协议也称为边际网关协议</p>
<ul>
<li>BGP协议是运行在各个自治(LS)系统，就是管理各个省的。</li>
</ul>
<p>为什么要使用BGP协议？</p>
<ul>
<li>互联网规模比较大</li>
<li>AS内部使用不同的路由(有的使用RIP，有的使用OSPF)协议，比较复杂以此需要一个统一的协议来管理</li>
<li>AS之间还需考虑除网络特性以外的因素，比如说政治，安全等等</li>
</ul>
<p>因此，BGP协议不能够找到一条到达目的最好的路由，但是可以找到比较好，比较合适的。</p>
<p>2.BGP发言人：一般是由AS中的边界路由器组成，比如说位于这个网络边界的就可以当这个网路的发言人，和其它网络通信。</p>
<ul>
<li>BGP不会关心内部网络</li>
<li>AS间通过BGP发言人交流信息</li>
<li>BGP发言人可以人为的配置，方便更好的管理。</li>
</ul>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>1.概述：UDP协议也称为用户数据报协议</p>
<ul>
<li>其只负责封装应用层发过来的数据报，并且不作如何处理，UDP协议中数据的大小取决于其接收应用层数据报的大小</li>
<li>UDP协议的数据一般是封装在IP数据报内容里面，其由UDP首部和UDP数据报数据构成</li>
</ul>
<p>2.具体内容：</p>
<p>UDP首部：(单位为比特位)</p>
<table>
<thead>
<tr>
<th>16位源端口号(用户机器进程端口)</th>
<th>16位目的端口号(目的机器通信进程端口)</th>
</tr>
</thead>
<tbody><tr>
<td>16位UDP长度(UDP数据的长度)</td>
<td>16位UDP校验和</td>
</tr>
</tbody></table>
<p>其它的都是UDP数据具体内容了</p>
<p>3.特点：</p>
<ul>
<li>UDP是无连接的协议，A与B发送消息，不需要提前建立连接，想发就发</li>
<li>UDP不能够保证可靠的交付数据，中间可能会有数据丢失</li>
<li>UDP面向报文传输，不对数据进行处理，就是发送一整个封装好的报文</li>
<li>UDP没有拥塞控制，其不会感知网络是否会发生拥塞</li>
<li>UDP首部内容比较简单，开销比较小</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>1.概述：其也称为传输控制协议，位置和UDP数据一样，都是封装在IP数据当中</p>
<p>2.特点：</p>
<ul>
<li>TCP是面向连接的协议，通信之前需要进行连接，就像打电话一样，你需要去接才能够通信</li>
<li>TCP是点对点的通信</li>
<li>TCP可以提供可靠的数据传输服务</li>
<li>TCP协议提供全双工通信，可以同时发送和接收</li>
<li>其是面向字节流的协议，把一块块数据看成字节来传输，方便处理数据</li>
</ul>
<p>3.TCP首部结构描述：(单位为比特位)</p>
<p><img src="/2020/02/25/jisuanjiwangluo/22.png" alt="TCP"></p>
<ul>
<li>序号：占32个比特位，范围:0~2^32-1，用来标记传输的字节，一个字节对应一个序号，这个序号代表的是TCP报文数据首字节的序号</li>
<li>确认号：占32个比特位，范围：0~2^32-1，表示期待收到的数据的首字节号</li>
<li>数据偏移：占4个比特位，单位位32位字(也就是4个字节)，表示数据偏移首部的距离</li>
<li>TCP标记：占6个比特位，每位的意义都不同，总共六位标记：</li>
</ul>
<table>
<thead>
<tr>
<th>标记</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>URG</td>
<td>urgent：紧急位，URG=1，表示紧急数据</td>
</tr>
<tr>
<td>ACK</td>
<td>确认位，ACK=1时表示确认号生效</td>
</tr>
<tr>
<td>PSH</td>
<td>push，推送位，PSH=1的时候，表示尽快把数据给应用层</td>
</tr>
<tr>
<td>RST</td>
<td>reset：重置位，RST=1，表示重新建立连接</td>
</tr>
<tr>
<td>SYN</td>
<td>同步位，SYN=1，表示连接请求报文</td>
</tr>
<tr>
<td>FIN</td>
<td>finish，FIN=1，表示释放连接</td>
</tr>
</tbody></table>
<ul>
<li>窗口：占16个比特位，指明允许对方的发送的数据量，也就是最大值</li>
<li>校验和：验证错误</li>
<li>紧急指针：URG=1时有效，指定了紧急数据在报文中的位置</li>
<li>TCP选项：最多占40个字节，支持未来的拓展</li>
</ul>
<h2 id="可靠传输的基本原理"><a href="#可靠传输的基本原理" class="headerlink" title="可靠传输的基本原理"></a>可靠传输的基本原理</h2><p>1.停止等待协议：来举个例子，或许说的搞清楚：</p>
<p>在无差错的情况下，发送方给接收方发送消息1，然后接收方收到消息以后，就向发送方发送确认收到消息，当发送方收到以后，继续发消息，然后以此类推。。。。</p>
<p>在这个过程中，发送方发出消息1的时候，会暂时停止发送消息2，此时等待</p>
<p>接收方发来的确认消息，当收到确认消息以后才会继续发送，这个就是停止等待协议。</p>
<p>当然也会出现差错的情况，如果说，消息在传输的途中丢失了：</p>
<ul>
<li><p>发送消息1的过程中，消息1丢失，接收方无法发送确认消息或者说，消息1收到了，但是发送确认消息的过程中消息丢失了，这就会让消息2等很久，如果说超过一定时间没有反应，则会超时重传，重新发送消息1.</p>
</li>
<li><p>如果是消息没有丢失，但是迟到了，也会进行超时重传。</p>
</li>
</ul>
<p>这个过程会有等待，停止的过程，会占用信道，导致信道效率不高。</p>
<ul>
<li>超时定时器：没发送一个消息，都会设置一个超时定时器，以便于超时重传的操作</li>
</ul>
<p>2.连续ARQ协议：自动重传协议</p>
<ul>
<li>滑动窗口：滑动窗口的大小固定，比如说大小为6个字节，那么其就可以占据着六个字节的信息，但是其占据的东西可以不断更新，把后面的字节信息也囊括进来。</li>
</ul>
<p>假设有连续的12个字节的报文需要发过来，而滑动窗口的大小为6，此时其就会占据前6个字节的数据，一个个连续发送，当第一个和第二个字节的数据被收到以后(发送确认消息过来)，此时窗口会向后移动两个位置，此时占据的就是3~8的位置，一个个字节批量发送才会向后移动。其可以发送窗口里面的所有数据，但是当确认号数据(需要发送的数据)到达目的地以后，窗口才会后后移，但是确认的过程缺少逐个的确认，开销比较大。</p>
<ul>
<li>累计确认：如果发送了上述的1<del>6号数据，而确认号为5，则当收到了确认号消息以后，就会告诉5之前的数据都确认了(连续发送确认)，便会移动窗口，变为6</del>11。等下我们看个例子就知道了。</li>
</ul>
<h2 id="TCP协议的可靠传输-基于ARQ协议"><a href="#TCP协议的可靠传输-基于ARQ协议" class="headerlink" title="TCP协议的可靠传输(基于ARQ协议)"></a>TCP协议的可靠传输(基于ARQ协议)</h2><p><img src="/2020/02/25/jisuanjiwangluo/23.png" alt></p>
<p>假设窗口大小为7，若发送的消息如上，那么窗口以前的都是已经确认发送过的字节序号，其之后的都是还未确认，并且不允许发送的字节序号(因为不属于自己管)，在滑动窗口内部则有已发送但是未确认的字节消息，还有未发送的可用窗口消息，如果23，24的消息确认以后，窗口就会右移两个位置变成：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/24.png" alt></p>
<p>以此类推把所有消息发送完，当然在上述过程，如果至少25，27发送并且收到了确认消息，而23，24未收到，则会等待，等待23，24的好消息，但是如果说超时了，就会从23开始重传，但是这样全部重传的效率很低，因此选择重传就诞生了：</p>
<ul>
<li><strong>选择重传</strong><ul>
<li>需要指定应该重传的字节</li>
<li>每一个字节都有32位(四个字节)唯一的序号，而在TCP首部的TCP选项当中(最多存四十个字节)，因此最多只能存十个序号，因此不可能会逐一记录需要重传的字节，地方毕竟就那么大，因此TCP选项里面记录的是重传数据的边界序号，比如说23，24，25，26这一段都需要重传，那么TCP选项里面记录的就是23和26的字节序号。</li>
</ul>
</li>
</ul>
<p>TCP的可靠传输大概就是这样完成的。</p>
<h2 id="TCP协议的流量控制"><a href="#TCP协议的流量控制" class="headerlink" title="TCP协议的流量控制"></a>TCP协议的流量控制</h2><p>1.目的：限制发送方的发送速率</p>
<p>2.实现方式：利用滑动窗口</p>
<p>3.过程：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/25.png" alt="TCP流量控制"></p>
<p>以上是发送方和接收方互发消息的过程，从上往下按照时间顺序：</p>
<p>首先，发送方会发送(首字节)序列号(seq)为1的数据，大小为100字节，之后又发送首字节序列号为101的数据，大小为100字节，然后接收方收到消息以后，就会发送确认消息给发送方，ACK=1表示消息已经确认了，ack=201表示下一次希望发过来的首字节数据序列号为201，rwnd=300告诉对方发送数据的时候窗口大小为300，之后，发送方发送首字节序列号(seq)为301的数据，数据大小为100字节，由于窗口大小为300，因此后面只能够发送200字节的数据，后面又开始发送序列号为401的数据，大小为200字节，接收方收到消息以后，发送确认消息，ACK=1，告诉对方我已经收到你的消息了，ack=601表示我下次希望收到的数据围殴601，rwnd=0表示现在窗口为0了，以控制对方发送的速率，就让对方暂时不发送了。之后如果想要对方发送数据了，就会发送rwnd=1000的消息给发送方，告诉他现在窗口大小为1000了，你可以发送数据过来了。</p>
<p><strong>注意！！！</strong>如果说最后发送rwnd=1000的消息在发送过程中出现了丢失，那么这个时候双方都不会发送消息，这是就会形成你等我，我等你的死锁状态，因此此时就出现了坚持定时器，来解决这个问题：</p>
<ul>
<li>坚持定时器：<ul>
<li>当收到窗口大小为0的消息之后，就会启动坚持定时器</li>
<li>坚持定时器每隔一段时间都会发送一个窗口探测报文，看看窗口是否发生了变化，如果说探测的时候发现它明明发送了rwnd=1000的消息，而我却没有收到，这个时候会叫他重发。</li>
</ul>
</li>
</ul>
<h2 id="TCP协议的拥塞控制"><a href="#TCP协议的拥塞控制" class="headerlink" title="TCP协议的拥塞控制"></a>TCP协议的拥塞控制</h2><p>1.对比流量控制：</p>
<table>
<thead>
<tr>
<th>流量控制</th>
<th>拥塞控制</th>
</tr>
</thead>
<tbody><tr>
<td>考虑点对点的通信量的控制</td>
<td>考虑整个网络，具有全局性</td>
</tr>
</tbody></table>
<p>2.控制拥塞的算法：</p>
<ul>
<li><p>慢启动算法：</p>
<ul>
<li>由小到大逐渐增加发送数据量</li>
<li>每收到一个报文确认，就会逐渐把数据量加一(1-&gt;2-&gt;4-&gt;8…指数增长)，让数据量发送变大</li>
<li>当数据量增大到一个慢启动阈值的时候，就不增加了，此时就会使用下面的算法：</li>
</ul>
</li>
<li><p>拥塞避免算法：</p>
<ul>
<li>维护一个拥塞窗口的变量</li>
<li>只要网络不拥塞，就试探把拥塞窗口调大，这个时候就是线性增长了</li>
</ul>
</li>
</ul>
<p>两个算法的过程如下：</p>
<p>前一个过程使用第一个算法，到达某种程度以后就启用第个算法</p>
<p><img src="/2020/02/25/jisuanjiwangluo/26.png" alt="TCP的拥塞控制"></p>
<h2 id="TCP连接的建立-三次握手"><a href="#TCP连接的建立-三次握手" class="headerlink" title="TCP连接的建立(三次握手)"></a>TCP连接的建立(三次握手)</h2><p><img src="/2020/02/25/jisuanjiwangluo/27.png" alt="三次握手"></p>
<ul>
<li>第一次握手发送方向接收方发送了：SYN=1,seq=x的数据报文，SYN是TCP标记，表示的是连接同步请求，就是请求建立连接的，并且还发送了序列号为x的报文</li>
<li>第二次握手，接收方收到了来自发送方请求连接的请求，并且向它发送确认消息：ACK=1，而且也向发送方发送SYN=1连接同步请求，并且希望发送方下次发送的数据的序列号为x+1，而且接收方也向发送方发生了序列号为y的数据，此时发送方已经建立了连接</li>
<li>第三次握手，发送方收到了接收方的数据请求，于是发送确认消息：ACK=1给接收方告诉它收到了连接的消息，并且同意连接，发送了序列号为x+1的数据报文(就是接收方想要的)的数据给接收方，接收方收到以后，也会建立起连接，TCP连接的建立完毕。之后就可以进行数据的传输。</li>
</ul>
<p>第一次握手和第二次握手时建立连接的过程，2，3次握手过程时未来同步各自的序号，便于建立可靠的连接。对于发送方而言，第一次握手和第二次握手的过程是同步已发送的过程，第三次握手消息发送以后就建立了连接，对于接收方而言，第一次握手的过程就是监听过程，监听第一次握手的消息，第二次握手发送到第三次握手接收之前是同步已接收的过程，第三次握手的消息收到以后就是建立连接的过程，此时接收方已经建立好了连接，双方开始进行通信。</p>
<p>或许有的读者会问道，既然我第二次握手就可以建立连接了，那我为什么还闲着没事干发送第三次握手的消息？</p>
<p>其实这也是未来避免连接请求报文传送到对方引起报错，避免数据丢失或者超时而引起的错误。举个例子：</p>
<p><img src="/2020/02/25/jisuanjiwangluo/28.png" alt="第三次握手的重要"></p>
<ul>
<li>假设第一次发送第一次握手的请求的时候，由于发送时间过长，发送的请求要经过很长时间才能够到达接收方，这个时候，自己也会用比较长的时间才能够收到第二次握手请求的确认消息，此时发送方会认为发送超时，就会第二次发送第一次握手的消息请求。(假设第一次发送的为1，为失效请求，第二次发送的为2，为有效请求)</li>
<li>如果第二次握手就开始全部建立连接的话，那么1的存在就会影响连接，因为接收方还是会收到1，还是会照常发送第二次握手，只不过是时间问题，但是2发送的请求要到的早一点，但是1的迟到也会给第二次握手造成影响。</li>
<li>因此就需要第三次握手来屏蔽这些无效请求，就会规定，发送方接收到第二次握手的请求后，发送了第三次握手请求之后，如果再遇到第二次握手的请求消息，就会不再发送第三次握手请求，避免失效消息1的影响和干扰，此时就可以建立可靠的连接。</li>
</ul>
<h2 id="TCP连接的释放-四次挥手"><a href="#TCP连接的释放-四次挥手" class="headerlink" title="TCP连接的释放(四次挥手)"></a>TCP连接的释放(四次挥手)</h2><p><img src="/2020/02/25/jisuanjiwangluo/29.png" alt="四次挥手"></p>
<ul>
<li>发送方发出第一次挥手的请求：FIN=1，即终止位标记为1，代表释放连接，并且发生了序列号为u的数据，此时发送方进入了连接结束第一次等待状态</li>
<li>接收方收到第一次挥手的请求后发送确认收到的消息，即第二次挥手请求：ACK=1(表示确认，告诉发送方我知道了)，seq=v(发送序列号为V的数据)，ack=u+1(希望下次收到序列号为u+1的数据)。此时发送方进入连接结束第二次等待状态，接收方进入关闭等待状态</li>
<li>接收方发送第二次挥手的请求是为了告诉发送方自己已经确认收到了，然后自己也需要去断开连接1，也要发送连接释放的请求，因此就发送了第三次握手的请求给发送方表示自己的连接释放请求：FIN=1(终止位标记为1，表示释放连接请求)，ACK=1，seq=w，ack=u+1.此时接收方进入最后确认状态。</li>
<li>发送方收到了来自接收方第三次挥手的请求以后，也要发送确认收到的消息，告诉接收方我已经收到了，即发出第四次挥手的消息请求：ACK=1,seq=u+1，ack=w+1，此时发送方设置一个等待计时器，等待时间过完，就进入关闭状态，接收方收到第四次挥手消息以后，也进入关闭状态，TCP连接的释放完毕。</li>
</ul>
<p>对于那个等待计时器等待的时间，一般是等2MSL的时间，我们来解释一下MSL。</p>
<p>MSL：最长报文段寿命(一般设置为两分钟)。</p>
<p>在2MSL的等待时间段内，发送方不会释放连接，那为什么要等2MSL，而不是MSL，或者3MSL的时间呢？</p>
<ul>
<li>因为最后一个报文的发送还没有确认收到，需要等一下</li>
<li>确保发送方的ACK可以到达接收方</li>
<li>如果说2MSL的时间内接收方没有收到，那么接收方会重新发送第三次挥手的消息，等待计时器也是为了确保连接的正确释放。</li>
<li>确保当前连接的所有报文都已经过期，便于释放。</li>
</ul>
<h2 id="套接字与套接字的编程"><a href="#套接字与套接字的编程" class="headerlink" title="套接字与套接字的编程"></a>套接字与套接字的编程</h2><p>1.概述：套接字指的是IP和port的组合，也就是我们所说的socket。，socket表示的是TCP连接的一端，通过套接字可以进行数据的发送和接收，而TCP连接是点对点的通信，因此需要两个套接字。</p>
<p>2.过程：</p>
<p>服务器：创建套接字-&gt;绑定套接字-&gt;监听套接字-&gt;接收处理信息</p>
<p>客户端：创建-&gt;连接-&gt;发送</p>
<p>3.分类：</p>
<ul>
<li>网络套接字：一般是跨机器，跨网络的通信</li>
<li>域套接字：通过域套接字文件进行通信，数据不需要经过协议栈，比较简单，并且速度快，消耗资源小，一般用于单机通信，就是自己内部的通信。</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>1.概述：应用层需要的就是往上对阶用户，并且提供丰富的服务，它会使用到以下各层为它服务</p>
<ul>
<li>比如说，它会利用UDP协议进行多媒体信息开发，比如说语言，视频，实时消息等等</li>
<li>它也会利用TCP进行可靠消息的传输，比如说金融交易，可靠通讯等等</li>
</ul>
<p>2.应用层定义的应用间通信的规则：</p>
<ul>
<li><p>定义应用进程的报文类型</p>
</li>
<li><p>报文的语法格式</p>
</li>
<li><p>应用进程发送数据的世纪和规则</p>
</li>
</ul>
<p>等等</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>1.概述：DNS也被称为域名系统，一般是域+名，DNS会把IP与端口的组合转化为域名，让我们便于使用和记忆，就比如说<a href="http://www.baidu.com就是一个域名，而它其实就是IP地址和端口的组合由DNS服务转换而来的，也是为了我们方便使用。" target="_blank" rel="noopener">www.baidu.com就是一个域名，而它其实就是IP地址和端口的组合由DNS服务转换而来的，也是为了我们方便使用。</a></p>
<p>2.组成：由点，字母和数字组成，点是用来分割不同的域，而域也分为顶级域，二级域，三级域等等，比如说<a href="http://www.baidu.com中www就是代表三级域，baidu就是代表二级域，com就是代表顶级域。" target="_blank" rel="noopener">www.baidu.com中www就是代表三级域，baidu就是代表二级域，com就是代表顶级域。</a></p>
<p>3.分类：</p>
<ul>
<li>顶级域：顶级域也会分为国家类和通用类，其中国家类由有cn(中国)，us(美国)，uk(英国)，ca(加拿大)等等，通用类分为com(公司)，net(网络服务机构)，gov(政府)，org(组织)等等</li>
<li>二级域：一般都是具体名字，比如说baidu，aliyun，qq，taobao等等</li>
<li>三级域：比如说www，tsinghua等等</li>
</ul>
<p>3.说明：DNS是建立在DNS服务器上的，而DNS服务器也会有不同的分层，便于管理：</p>
<ul>
<li>根域名服务器</li>
<li>根域名服务器下面就是顶级域名服务器</li>
<li>顶级域名服务器再往下就是域名服务器</li>
</ul>
<p>4.DNS过程：输入域名以后，设备会查询本地域名服务器，如果有对于的IP地址就还可，如果没有就会查找根域名服务器，找到对应的顶级域名服务器，从这里面找IP，再往下找域名服务器，最终返回对应的IP进行访问。</p>
<h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>1.概述：DHCP协议也称为动态主机设置协议</p>
<ul>
<li>DHCP是一个局域网协议</li>
<li>DHCP是应用了UDP协议的应用层协议</li>
</ul>
<p>2.功能：比如说，我们的电脑设备有时候会在宿舍，有时候会在学校，而不同的地方IP地址，网络环境也不同，那我们为什么不需要去配置IP地址来实现通信呢，它电脑本身又是怎么处理的呢？这个就是DHCP协议实现的即插即联网，DHCP会分配一个临时的内网IP，再结合NAT技术，去访问外网，因此实现通信，我们就不需要配置了。但是这个临时IP有一个租期，过期以后如果想继续使用就可以续租。</p>
<p>3.过程：假设某个网络环境下加入了一个新设备：</p>
<ul>
<li>DHCP服务器监听默认端口67</li>
<li>主机使用UDP协议广播DHCP协议发现报文请求，以找到DHCP服务器</li>
<li>DHCP服务器发送DHCP提供报文，告诉主机我在这里</li>
<li>主机向DHCP服务器发出DHCP请求报文</li>
<li>DHCP服务器回应主机并且提供IP地址</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>1.概述：HTTP协议也称为超文本传输协议</p>
<ul>
<li>其会使用一个超文本(带超链接的文本)，其格式为http://&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;，主机和端口对应的是设备或者某个网络资源的IP和端口的组合，路径一般指向特定的内容。</li>
<li>HTTP协议是可靠的数据传输协议，其基于TCP进行传输，可以传输各种web内容，比如说文本，文件，图片，音频，动图，视频等等</li>
</ul>
<p>2.HTTP协议的具体过程：</p>
<p>web服务器接收客户端的连接-&gt;接收到请求报文-&gt;处理请求，看看客户端需要请求哪些内容-&gt;访问web资源，看看我web资源里面有没有这样内容-&gt;构造应答，我把这些内容整理一下-&gt;发送应答，把这些内容发送给客户端</p>
<p>3.HTTP请求方法：GET,POST,DELETE,UPDATE,PUT，OPTIONS，PATCH,HEAD,TRACE。</p>
<ul>
<li>GET:获取指定的服务端资源</li>
<li>POST:提交数据到服务端</li>
<li>DELETE:删除指定的服务端资源</li>
<li>UPDATE:更新服务端资源等等</li>
</ul>
<p>等等</p>
<p>那我们如何指定这个资源呢？</p>
<ul>
<li>在地址中指定，比如说http地址里面有一些参数可以指明我需要指定哪些资源，例如<a href="http://coding.imooc.com/class/355.html" target="_blank" rel="noopener">http://coding.imooc.com/class/355.html</a>, 这个网址就在域名后面指定了/class，拉取课程内容，还指定了/355，表示的是第355个资源。</li>
<li>在请求数据中指定，对于这个请求和应答过程涉及到两种http报文：</li>
</ul>
<p>请求报文：</p>
<table>
<thead>
<tr>
<th>报文各个部分</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>请求方法，请求地址，HTTP版本</td>
<td>POST(请求方法)，<a href="http://coding.imooc.com(请求地址)，HTTP/1.1表示请求版本" target="_blank" rel="noopener">http://coding.imooc.com(请求地址)，HTTP/1.1表示请求版本</a></td>
</tr>
<tr>
<td>请求头</td>
<td>Accept-Encoding：ip，Accept-Lauguage：zh-cn等等(这个不用管)</td>
</tr>
<tr>
<td>请求内容</td>
<td>{“sort”:0,”unlearn”:0,”page”:0}等等</td>
</tr>
</tbody></table>
<p>应答报文：</p>
<p>分为这几个部分：</p>
<ul>
<li>HTTP版本，状态码，状态解释</li>
<li>应答头</li>
<li>应答内容</li>
</ul>
<p>状态码的说明：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>200~299</td>
<td>成功状态码</td>
</tr>
<tr>
<td>300~399</td>
<td>重定向状态码</td>
</tr>
<tr>
<td>400~499</td>
<td>客户端错误状态码</td>
</tr>
<tr>
<td>500~599</td>
<td>服务端错误状态码</td>
</tr>
</tbody></table>
<h2 id="HTTP工作的结构"><a href="#HTTP工作的结构" class="headerlink" title="HTTP工作的结构"></a>HTTP工作的结构</h2><p>1.web缓存：web内容分为热门内容和冷门内容，一般满足二八原则，20%的热门内容和80%的冷门内容，对于热门内容需要优先缓存起来，提高访问数据量和速度，提高服务质量</p>
<p>2.web代理：client-&gt;proxy(代理)-&gt;server</p>
<p>客户端域服务端之间的访问连接有时候会利用代理，这也是为了屏蔽server部署的架构，保证server的安全，避免其暴露在危险的环境中</p>
<ul>
<li>正向代理：代理client访问server</li>
<li>反向代理：代理server提供数据给client</li>
</ul>
<p>3.CDN：也称为内容分发网络，可以把一个大型网络分为多个CDN到各个地方，便于访问，加快多媒体内容访问速度</p>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>1.对比HTTP协议</p>
<ul>
<li>HTTP协议是明文传输，对于一些比较重要的内容来说是不安全的</li>
<li>HTTPs协议可以提供加密，更加安全</li>
</ul>
<p>1.加密模型：</p>
<ul>
<li>对称加密：使用同一把密匙进行加密和解密</li>
<li>非对称加密：其加密的密匙和解密的密匙不一样，分别为公钥和私钥，但是这一对密钥也有一定的数学关系，公钥是给大家使用的，对外公开，私钥是自己使用的，不对外公开。一般公钥加密，私钥解密。</li>
</ul>
<p>2.数字证书：可信任组织颁发给特定对象的认证，证书格式如下：</p>
<table>
<thead>
<tr>
<th>证书格式，版本号</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>证书序列号</td>
<td></td>
</tr>
<tr>
<td>签名算法</td>
<td></td>
</tr>
<tr>
<td>有效器</td>
<td></td>
</tr>
<tr>
<td>对象名称</td>
<td></td>
</tr>
<tr>
<td>对象公开的密匙</td>
<td></td>
</tr>
</tbody></table>
<p>3.SSL：安全套阶层，位于应用层和传输层之间</p>
<ul>
<li>保证了数据安全和完整性</li>
<li>对传输层数据进行加密后再传输</li>
</ul>
<p>4.HTTPS的过程：</p>
<ul>
<li>客户端和服务器通过443端口进行TCP连接</li>
<li>进行SSL安全参数握手，之后便于进行数据加密</li>
<li>客户端发送数据，由SSL加密</li>
<li>服务端发送数据，涉及到SSL的加密和解密</li>
</ul>
<p>SSL安全握手过程：</p>
<ul>
<li>客户端生成随机数1，并且告诉服务端协议版本和加密算法，把随机数1发送给服务端</li>
<li>服务端确定加密算法和发送数字证书给客户端，生成随机数2，发送随机数2给客户端</li>
<li>客户端确认证书是否有效，如果有效，就生成随机数3，使用服务器提供的公钥(数字证书提供)加密随机数3，发送给服务器</li>
<li>服务端解密随机数3，得到随机数，此时双方有随机数1，2，3</li>
<li>双方根据随机数1，2，3和相同的加密算法分别生成密匙(利用对称加密算法)，此时密钥没有进行传输，保证了密钥的安全，而且随机数3也是安全的</li>
<li>双方利用对称密钥进行加密通信</li>
</ul>
<p>这个过程利用了对称加密和非对称加密，二者综合使用了。</p>
<h1 id="实践环节"><a href="#实践环节" class="headerlink" title="实践环节"></a>实践环节</h1><p>本次实践环节会实现TCP,UDP,IP报文解析器，让我们更加深入的了解计网。</p>
<h2 id="基于之前的操作系统实践搭建服务器基本框架"><a href="#基于之前的操作系统实践搭建服务器基本框架" class="headerlink" title="基于之前的操作系统实践搭建服务器基本框架"></a>基于之前的操作系统实践搭建服务器基本框架</h2><p>网络工作模式：</p>
<p>混杂模式：接收所有经过网卡设备的数据</p>
<p>非混杂模式：只接收目的地址指向自己的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import json</span><br><span class="line">from operate_system.pool import ThreadPool as tp</span><br><span class="line">from operate_system.Task import AsyncTask</span><br><span class="line">class ProcessTask(AsyncTask):              #线程处理任务</span><br><span class="line">    def __init__(self,packet,*args,**kwargs):</span><br><span class="line">        self.packet &#x3D;packet           #接收报文信息</span><br><span class="line">        # AsyncTask(func&#x3D;self.process,*args,**kwargs)</span><br><span class="line">        super(ProcessTask,self).__init__(func&#x3D;self.process,*args,**kwargs)</span><br><span class="line">    def process(self):                      #线程实现的工作具体路基</span><br><span class="line">class Server:     #实现服务器，提供设置混杂模式捕捉到当前网络的各种报文信息，并且输出</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.socket &#x3D; socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_IP)</span><br><span class="line">        #第一个设置socket工作环境为IPV4，第二个设置套接字的类型为原始套接字，第三个设置工作协议为IP协议（可为其它）</span><br><span class="line">        self.ip &#x3D; &#39;192.168.0.101&#39;       #自己的主机IP，当前网络环节下的IP，可以CMD中输入ipconfig查查看</span><br><span class="line">        self.port&#x3D;8888</span><br><span class="line">        self.socket.bind((self.ip,self.port))     #绑定</span><br><span class="line">        self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)</span><br><span class="line">        #设置混杂模式</span><br><span class="line">        self.socket.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)</span><br><span class="line">        self.pool &#x3D; tp(10)            #建立一个大小为10的线程池</span><br><span class="line">        self.pool.start()</span><br><span class="line">    def loop(self):</span><br><span class="line">        while True:</span><br><span class="line">            #接收</span><br><span class="line">            packet,addr &#x3D; self.socket.recvfrom(65565)  #接收报文信息</span><br><span class="line">            #生成task</span><br><span class="line">            task &#x3D; ProcessTask(packet)    #处理报文</span><br><span class="line">            #提交任务线程到线程池</span><br><span class="line">            self.pool.put(task)</span><br><span class="line">            #获取结果</span><br><span class="line">            result &#x3D; task.get_result()    #提供异步获得任务获得处理结果</span><br><span class="line">            result&#x3D;json.dumps(          #使用json设置打印格式</span><br><span class="line">                result,indent&#x3D;4         #缩进为4</span><br><span class="line">            )</span><br><span class="line">            print(result)</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    server &#x3D; Server()</span><br><span class="line">    server.loop()</span><br></pre></td></tr></table></figure>

<h2 id="谈谈python如何操作字节序列"><a href="#谈谈python如何操作字节序列" class="headerlink" title="谈谈python如何操作字节序列"></a>谈谈python如何操作字节序列</h2><p>字节序是什么？就是字节的排列顺序，但是字节也分为高字节和低字节，比如说255(十进制)=0000 1111(二进制)，前面四位0000就是高字节序，后面四个就是低字节序</p>
<p>字节序分类：</p>
<ul>
<li>大端字节序：高字节在前，低字节在后，这个也是我们人类的习惯使用</li>
<li>小端字节序：低字节在前，高字节在后，这个就是主机经常使用的，因为计算机电路会优先处理低位字节。</li>
</ul>
<p>格式字符的操作：</p>
<table>
<thead>
<tr>
<th>格式字符</th>
<th>格式以后的类型</th>
<th>占字节的大小</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>整数</td>
<td>1</td>
</tr>
<tr>
<td>H</td>
<td>整数</td>
<td>2</td>
</tr>
<tr>
<td>L</td>
<td>整数</td>
<td>4</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>-</td>
</tr>
</tbody></table>
<p>在python当中一般是用struct包里面的unpack函数来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mport struct</span><br><span class="line">bin_str&#x3D;b&#39;ABCD1234&#39;          #八个字节</span><br><span class="line">print(bin_str)</span><br><span class="line">result&#x3D;struct.unpack(&#39;&gt;BBBBBBBB&#39;,bin_str)    #B为格式化字符，由于bin_str有八个字节，格式字符要八个,&gt;表示大端字节序</span><br><span class="line">print(result)</span><br><span class="line">result &#x3D; struct.unpack(&#39;&gt;HHHH&#39;,bin_str)       #H格式化2个字节，而bin_str有8个字节，因此要4个H</span><br><span class="line">print(result)</span><br><span class="line">result &#x3D; struct.unpack(&#39;&gt;LL&#39;,bin_str)</span><br><span class="line">print(result)</span><br><span class="line">result &#x3D; struct.unpack(&#39;&gt;8s&#39;,bin_str)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<h2 id="IP报文解析器"><a href="#IP报文解析器" class="headerlink" title="IP报文解析器"></a>IP报文解析器</h2><p>要把IP报文的各个细节解析出来，我们就得了解IP的具体组成了，以下的注释里面我都提到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># ! _*_ encoding&#x3D;utf-8 _*_</span><br><span class="line"></span><br><span class="line">import struct</span><br><span class="line">import socket</span><br><span class="line">def data_str(data):     #获取IP数据报里面的IP数据</span><br><span class="line">    length&#x3D;len(data)</span><br><span class="line">    data&#x3D;struct.unpack(length*&#39;B&#39;,data)</span><br><span class="line">    string&#x3D;&#39;&#39;</span><br><span class="line">    for ch in data:</span><br><span class="line">        if ch&gt;&#x3D;127 or ch&lt;32:    #不可打印字符</span><br><span class="line">            string+&#x3D;&#39;.&#39;</span><br><span class="line">        else:</span><br><span class="line">            string+&#x3D;chr(ch)</span><br><span class="line">    return string</span><br><span class="line"></span><br><span class="line">class IPParser:   #IP报文解析器</span><br><span class="line">    IP_HEADER_LENGTH&#x3D;20;   #IP头部长度为20字节</span><br><span class="line">    @classmethod</span><br><span class="line">    def parser_IP_header(cls,packet_header):</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        IP头部重要内容：</span><br><span class="line">        第一行：四位IP_version 4为头部长度 服务类型 16为总长度</span><br><span class="line">        第二行：16位标识符 三位标记位 3位片偏移</span><br><span class="line">        第三行：8位TTL，8位协议 16位校验和</span><br><span class="line">        第四行：32位源IP地址</span><br><span class="line">        第五行：32位目的IP地址</span><br><span class="line">        :param packet_header:</span><br><span class="line">        :return:</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        line1 &#x3D; struct.unpack(&#39;&gt;BBH&#39;,packet_header[:4])    #获取IP头部第一行信息</span><br><span class="line">        ip_version &#x3D; line1[0]&gt;&gt;4     #第一个字节有八位分别存储IPversion和头部长度，比如说11110000,这里表示第一个字节右移4位，变成1111，就是ipversion</span><br><span class="line">        ipheader_length &#x3D; line1[0]&amp;15  #15的二进制表示为：00001111,二者相与只取后四位，即头部长度</span><br><span class="line">        ip_length &#x3D; line1[2]     #跳过服务类型，为总长度，第二行</span><br><span class="line">        line3 &#x3D; struct.unpack(&#39;&gt;BBH&#39;,packet_header[8:12])</span><br><span class="line">        TTL &#x3D; line3[0]         #第一个B</span><br><span class="line">        xieyi &#x3D; line3[1]       #第二个B</span><br><span class="line">        iph_checksum &#x3D; line3[2]    #第三个H</span><br><span class="line">        line4&#x3D;struct.unpack(&#39;&gt;4s&#39;,packet_header[12:16])</span><br><span class="line">        origin_ip &#x3D; socket.inet_ntoa(line4[0])         #域名转成ip地址</span><br><span class="line">        line5&#x3D;struct.unpack(&#39;&gt;4s&#39;,packet_header[16:20])</span><br><span class="line">        destination_ip&#x3D;socket.inet_ntoa(line5[0])</span><br><span class="line">        return &#123;                   #返回IP头部信息</span><br><span class="line">            &#39;ip_version&#39;:ip_version,</span><br><span class="line">            &#39;ipheader_length&#39;:ipheader_length,</span><br><span class="line">            &#39;ip_length&#39;:ip_length,</span><br><span class="line">            &#39;TTL&#39;:TTL,</span><br><span class="line">            &#39;xieyi&#39;:xieyi,</span><br><span class="line">            &#39;ip_checksum&#39;:iph_checksum,</span><br><span class="line">            &#39;origin_ip&#39;:origin_ip,</span><br><span class="line">            &#39;destination_ip&#39;:destination_ip</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pass</span><br><span class="line">    @classmethod</span><br><span class="line">    def parser(cls,packet):</span><br><span class="line">        ip_header &#x3D; packet[:20]    #前20字节为IP头部</span><br><span class="line">        return cls.parser_IP_header(ip_header)</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p>如果要打印出IP报文的具体内容就可以在我们之前构架的服务器上进行实现，把具体实现逻辑写入到线程处理类的process函数中。</p>
<h2 id="UDP报文解析器"><a href="#UDP报文解析器" class="headerlink" title="UDP报文解析器"></a>UDP报文解析器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># ! _*_ encoding&#x3D;utf-8 _*_</span><br><span class="line"></span><br><span class="line">import struct</span><br><span class="line">class TransParser:</span><br><span class="line">    IP_HEADER_OFFSET&#x3D;20   #由于UDP报文的数据是封装在IP报文数据里面的，因此是IP头部之外的</span><br><span class="line">    UDP_HEADER_LENGTH&#x3D;8   #UDP头部的字节长度</span><br><span class="line">    TCP_HEADER_LENGTH&#x3D;20   #TCP头部的字节长度</span><br><span class="line">def data_str(data):         #获取具体数据</span><br><span class="line">    length&#x3D;len(data)</span><br><span class="line">    data&#x3D;struct.unpack(length*&#39;B&#39;,data)</span><br><span class="line">    string&#x3D;&#39;&#39;</span><br><span class="line">    for ch in data:</span><br><span class="line">        if ch&gt;&#x3D;127 or ch&lt;32:    #不可打印字符</span><br><span class="line">            string+&#x3D;&#39;.&#39;</span><br><span class="line">        else:</span><br><span class="line">            string+&#x3D;chr(ch)</span><br><span class="line">    return string</span><br><span class="line"></span><br><span class="line">class UDPParser(TransParser):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    1.16为源端口 16为目的端口</span><br><span class="line">    2.16为UDP长度 16位校验和</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    @classmethod</span><br><span class="line">    def UDP_header(cls,UDP_header):</span><br><span class="line">        line&#x3D;struct.unpack(&#39;&gt;HHHH&#39;,UDP_header)</span><br><span class="line">        return &#123;</span><br><span class="line">            &#39;origin_port&#39;:line[0],</span><br><span class="line">            &#39;destination_port&#39;:line[1],</span><br><span class="line">            &#39;UDP_length&#39;:line[2],</span><br><span class="line">            &#39;check_sum&#39;:line[3]</span><br><span class="line">        &#125;</span><br><span class="line">        pass</span><br><span class="line">    @classmethod</span><br><span class="line">    def UDP_parser(cls,packet):</span><br><span class="line">        UDP_header&#x3D;packet[cls.IP_HEADER_OFFSET:cls.IP_HEADER_OFFSET+cls.UDP_HEADER_LENGTH]</span><br><span class="line">        data&#x3D;packet[cls.IP_HEADER_OFFSET+cls.UDP_HEADER_LENGTH:]</span><br><span class="line">        data&#x3D;data_str(data)</span><br><span class="line">        result&#x3D;cls.UDP_header(UDP_header)  #UDP头部内容</span><br><span class="line">        result[&#39;data&#39;]&#x3D;data                 #UDP数据报文数据</span><br><span class="line">        return result                       #UDP报文</span><br></pre></td></tr></table></figure>

<h2 id="TCP报文解析器"><a href="#TCP报文解析器" class="headerlink" title="TCP报文解析器"></a>TCP报文解析器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># ! _*_ encoding&#x3D;utf-8 _*_</span><br><span class="line">from Computer_Network.processor.trans.UDPParser import TransParser</span><br><span class="line">import struct</span><br><span class="line">def data_str(data):     #获取TCP报文中的TCP数据</span><br><span class="line">    length&#x3D;len(data)</span><br><span class="line">    data&#x3D;struct.unpack(length*&#39;B&#39;,data)</span><br><span class="line">    string&#x3D;&#39;&#39;</span><br><span class="line">    for ch in data:</span><br><span class="line">        if ch&gt;&#x3D;127 or ch&lt;32:    #不可打印字符</span><br><span class="line">            string+&#x3D;&#39;.&#39;</span><br><span class="line">        else:</span><br><span class="line">            string+&#x3D;chr(ch)</span><br><span class="line">    return string</span><br><span class="line"></span><br><span class="line">class TCPParser(TransParser):</span><br><span class="line">    @classmethod</span><br><span class="line">    def TCP_header_parser(cls,tcp_header):</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        TCP头部：</span><br><span class="line">        1.16位源端口 16位目的端口</span><br><span class="line">        2.32位序列号</span><br><span class="line">        3.32位确认号</span><br><span class="line">        4.4位数据偏移 6位保留字段 6位标记号 16位窗口长度</span><br><span class="line">        5.16位校验和 16位紧急指针</span><br><span class="line">        :param tcp_header:</span><br><span class="line">        :return:</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        line1 &#x3D; struct.unpack(&#39;&gt;HH&#39;,tcp_header[:4])  #获取TCP头部第一行数据，前四个字节</span><br><span class="line">        origin_port&#x3D;line1[0]    #源端口</span><br><span class="line">        des_port&#x3D;line1[1]       #目的端口</span><br><span class="line">        line2&#x3D;struct.unpack(&#39;&gt;L&#39;,tcp_header[4:8])     #获取TCP头部第二行数据</span><br><span class="line">        xuliehao&#x3D;line2[0]                              #序列号</span><br><span class="line">        line3 &#x3D; struct.unpack(&#39;&gt;L&#39;,tcp_header[8:12])   </span><br><span class="line">        OK_num&#x3D;line3[0]               #确认号</span><br><span class="line">        line4&#x3D;struct.unpack(&#39;&gt;BBH&#39;,tcp_header[12:16])</span><br><span class="line">        data_offset&#x3D;line4[0]&gt;&gt;4      #数据偏移，因为只占4个比特位，半个字节，因此需要作移位处理获得</span><br><span class="line">        flags&#x3D;line4[1]&amp;int(&#39;00111111&#39;,2)       #进行与运算，获取6个比特位的标记号</span><br><span class="line">        FIN&#x3D;flags&amp;1         #通过与运算获得终止位标记</span><br><span class="line">        SYN&#x3D;(flags &gt;&gt;1)&amp;1     #通过移位和与运算获得同步位标记，下面都是以此类推，不多讲</span><br><span class="line">        RST&#x3D;(flags &gt;&gt;2)&amp;1</span><br><span class="line">        PSH&#x3D;(flags &gt;&gt;3)&amp;1</span><br><span class="line">        ACK&#x3D;(flags &gt;&gt;4)&amp;1</span><br><span class="line">        URG&#x3D;(flags &gt;&gt;5)&amp;1</span><br><span class="line">        win_length&#x3D;line4[2]</span><br><span class="line">        line5&#x3D;struct.unpack(&#39;&gt;HH&#39;,tcp_header[16:20])</span><br><span class="line">        check_num&#x3D;line5[0]</span><br><span class="line">        URG_pin&#x3D;line5[1]</span><br><span class="line">        return &#123;              #返回TCP头部具体信息</span><br><span class="line">            &#39;origin_port&#39;:origin_port,</span><br><span class="line">            &#39;des_port&#39;:des_port,</span><br><span class="line">            &#39;xuliehao&#39;:xuliehao,</span><br><span class="line">            &#39;OK_num&#39;:OK_num,</span><br><span class="line">            &#39;data_offset&#39;:data_offset,</span><br><span class="line">            flags:&#123;</span><br><span class="line">                &#39;FIN&#39;:FIN,</span><br><span class="line">                &#39;SYN&#39;:SYN,</span><br><span class="line">                &#39;RST&#39;:RST,</span><br><span class="line">                &#39;PSH&#39;:PSH,</span><br><span class="line">                &#39;ACK&#39;:ACK,</span><br><span class="line">                &#39;URG&#39;:URG,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            &#39;win_length&#39;:win_length,</span><br><span class="line">            &#39;check_num&#39;:check_num,</span><br><span class="line">            &#39;URG_pin&#39;:URG_pin</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    @classmethod</span><br><span class="line">    def parser(cls,packet):</span><br><span class="line">        tcp_header&#x3D;packet[cls.IP_HEADER_OFFSET:cls.IP_HEADER_OFFSET+cls.TCP_HEADER_LENGTH]</span><br><span class="line">        data &#x3D; packet[cls.IP_HEADER_OFFSET + cls.TCP_HEADER_LENGTH:]</span><br><span class="line">        data &#x3D; data_str(data)</span><br><span class="line">        result &#x3D; cls.TCP_header_parser(tcp_header)</span><br><span class="line">        result[&#39;data&#39;] &#x3D; data</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h2 id="调用TCP，UDP，IP报文解析器"><a href="#调用TCP，UDP，IP报文解析器" class="headerlink" title="调用TCP，UDP，IP报文解析器"></a>调用TCP，UDP，IP报文解析器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import json</span><br><span class="line">from operate_system.pool import ThreadPool as tp</span><br><span class="line">from operate_system.Task import AsyncTask</span><br><span class="line">from Computer_Network.processor.trans.UDPParser import UDPParser</span><br><span class="line">from Computer_Network.processor.net.parser import IPParser</span><br><span class="line">from Computer_Network.processor.trans.TCPParser import TCPParser</span><br><span class="line">class ProcessTask(AsyncTask):</span><br><span class="line">    def __init__(self,packet,*args,**kwargs):</span><br><span class="line">        self.packet &#x3D;packet</span><br><span class="line">        # AsyncTask(func&#x3D;self.process,*args,**kwargs)</span><br><span class="line">        super(ProcessTask,self).__init__(func&#x3D;self.process,*args,**kwargs)</span><br><span class="line">    def process(self):</span><br><span class="line">        # ip_header&#x3D;IPParser.parser(self.packet)</span><br><span class="line">        # return ip_header</span><br><span class="line">        heder&#x3D;&#123;</span><br><span class="line">            &#39;IP_header&#39;:None,</span><br><span class="line">            &#39;tans_header:&#39;:None</span><br><span class="line">        &#125;</span><br><span class="line">        ip_header &#x3D; IPParser.parser(self.packet)</span><br><span class="line">        heder[&#39;IP_header&#39;]&#x3D;ip_header</span><br><span class="line">        if ip_header[&#39;xieyi&#39;]&#x3D;&#x3D;17:    #表示协议位UDP协议</span><br><span class="line">            udp_header&#x3D;UDPParser.UDP_parser(self.packet)</span><br><span class="line">            heder[&#39;tans_header:&#39;]&#x3D;udp_header</span><br><span class="line">        if ip_header[&#39;xieyi&#39;]&#x3D;&#x3D;6:</span><br><span class="line">            tcp_header&#x3D;TCPParser.parser(self.packet)</span><br><span class="line">            heder[&#39;tans_header:&#39;]&#x3D;tcp_header</span><br><span class="line">        return heder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line">class Server:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>结果如下(部分数据)：</p>
<p>运行的时候，如果你是使用pycharm的话，因为混杂模式需要权限，因此需要用管理员模式打开，才能够真正进入混杂模式，其它的编辑器也是如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;IP_header&quot;: &#123;</span><br><span class="line">        &quot;ip_version&quot;: 4,</span><br><span class="line">        &quot;ipheader_length&quot;: 5,</span><br><span class="line">        &quot;ip_length&quot;: 40,</span><br><span class="line">        &quot;TTL&quot;: 64,</span><br><span class="line">        &quot;xieyi&quot;: 6,</span><br><span class="line">        &quot;ip_checksum&quot;: 40147,</span><br><span class="line">        &quot;origin_ip&quot;: &quot;192.168.0.102&quot;,</span><br><span class="line">        &quot;destination_ip&quot;: &quot;204.79.197.254&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tans_header:&quot;: &#123;</span><br><span class="line">        &quot;origin_port&quot;: 49586,</span><br><span class="line">        &quot;des_port&quot;: 443,</span><br><span class="line">        &quot;xuliehao&quot;: 2379595048,</span><br><span class="line">        &quot;OK_num&quot;: 3297254609,</span><br><span class="line">        &quot;data_offset&quot;: 5,</span><br><span class="line">        &quot;16&quot;: &#123;</span><br><span class="line">            &quot;FIN&quot;: 0,</span><br><span class="line">            &quot;SYN&quot;: 0,</span><br><span class="line">            &quot;RST&quot;: 0,</span><br><span class="line">            &quot;PSH&quot;: 0,</span><br><span class="line">            &quot;ACK&quot;: 1,</span><br><span class="line">            &quot;URG&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;win_length&quot;: 1020,</span><br><span class="line">        &quot;check_num&quot;: 26806,</span><br><span class="line">        &quot;URG_pin&quot;: 0,</span><br><span class="line">        &quot;data&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#123;</span><br><span class="line">    &quot;IP_header&quot;: &#123;</span><br><span class="line">        &quot;ip_version&quot;: 4,</span><br><span class="line">        &quot;ipheader_length&quot;: 5,</span><br><span class="line">        &quot;ip_length&quot;: 115,</span><br><span class="line">        &quot;TTL&quot;: 53,</span><br><span class="line">        &quot;xieyi&quot;: 17,</span><br><span class="line">        &quot;ip_checksum&quot;: 55278,</span><br><span class="line">        &quot;origin_ip&quot;: &quot;183.232.127.242&quot;,</span><br><span class="line">        &quot;destination_ip&quot;: &quot;192.168.0.102&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tans_header:&quot;: &#123;</span><br><span class="line">        &quot;origin_port&quot;: 8000,</span><br><span class="line">        &quot;destination_port&quot;: 63675,</span><br><span class="line">        &quot;UDP_length&quot;: 95,</span><br><span class="line">        &quot;check_sum&quot;: 21212,</span><br><span class="line">        &quot;data&quot;: &quot;.8Y.....3A......i.....;l..k.a...zf.(...)...P..L....*R.....n.w ..0.q.:.@i.u..&#x3D;J..#&gt;..G&lt;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#123;</span><br><span class="line">    &quot;IP_header&quot;: &#123;</span><br><span class="line">        &quot;ip_version&quot;: 4,</span><br><span class="line">        &quot;ipheader_length&quot;: 6,</span><br><span class="line">        &quot;ip_length&quot;: 36,</span><br><span class="line">        &quot;TTL&quot;: 1,</span><br><span class="line">        &quot;xieyi&quot;: 2,</span><br><span class="line">        &quot;ip_checksum&quot;: 33709,</span><br><span class="line">        &quot;origin_ip&quot;: &quot;192.168.0.1&quot;,</span><br><span class="line">        &quot;destination_ip&quot;: &quot;224.0.0.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tans_header:&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博主寄语"><a href="#博主寄语" class="headerlink" title="博主寄语"></a>博主寄语</h1><p>这篇博客博主花了比较多的心思，写博客的过程也是几次修改，并且加入了很多示意图，为了能够讲的更加清楚，我也特意招六很多图片，有一些是自己弄出来的，有的是网上找的。这已经不是一篇博客，而是充满博主心血的作品，希望读者细心阅读，如果有的地方出现了错误或者理解不清楚的，欢迎与博主华山论剑。希望读者们能够理解计算机网络的世界，探索世界的真理。</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://liujunchi-bot.github.io">John Doe</a></p><p> <span>Link:  </span><a href="http://liujunchi-bot.github.io/2020/02/25/jisuanjiwangluo/">http://liujunchi-bot.github.io/2020/02/25/jisuanjiwangluo/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="nextSlogan" href="/2020/02/19/caozuoxitong/" title="玩转操作系统"><span>NextPost ></span><br><span class="nextTitle">玩转操作系统</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  //- id: '驰哥趣谈计算机网络',
  //- owner: 'liujunchi-bot',
  //- repo: 'Blog-Comment',
  //- oauth: {
  //-   client_id: 'fcc11412ea5eb9310de3',
  //-   client_secret: 'fb83a32085e0e8570fd37c38d4909a2436776fde',
  //- },
  id: '{% raw %}{{ page.date }}{% endraw %}',
  owner: 'liujunchi-bot',
  repo: 'Blog-Comment',
  oauth: {
    client_id: 'fcc11412ea5eb9310de3',
    client_secret: 'fb83a32085e0e8570fd37c38d4909a2436776fde',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计网到底是个啥"><span class="toc-number">1.1.</span> <span class="toc-text">计网到底是个啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计网发展简史"><span class="toc-number">1.2.</span> <span class="toc-text">计网发展简史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算机网络的发展-四个阶段"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机网络的发展(四个阶段)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计网的层次结构"><span class="toc-number">1.3.</span> <span class="toc-text">计网的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#层次结构下的两个模型"><span class="toc-number">1.3.1.</span> <span class="toc-text">层次结构下的两个模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现代互联网的网络拓扑"><span class="toc-number">1.4.</span> <span class="toc-text">现代互联网的网络拓扑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计网的性能指标"><span class="toc-number">1.5.</span> <span class="toc-text">计网的性能指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络接口层"><span class="toc-number">2.</span> <span class="toc-text">网络接口层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#物理层"><span class="toc-number">2.1.</span> <span class="toc-text">物理层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据链路层"><span class="toc-number">2.2.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据链路层的差错检测"><span class="toc-number">2.3.</span> <span class="toc-text">数据链路层的差错检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最大传输单元MTU"><span class="toc-number">2.4.</span> <span class="toc-text">最大传输单元MTU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以太网协议"><span class="toc-number">2.5.</span> <span class="toc-text">以太网协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络层"><span class="toc-number">3.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP协议"><span class="toc-number">3.1.</span> <span class="toc-text">IP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP协议的转发流程"><span class="toc-number">3.2.</span> <span class="toc-text">IP协议的转发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP协议与RARP协议"><span class="toc-number">3.3.</span> <span class="toc-text">ARP协议与RARP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP地址的子网划分"><span class="toc-number">3.4.</span> <span class="toc-text">IP地址的子网划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络地址转NAT技术"><span class="toc-number">3.5.</span> <span class="toc-text">网络地址转NAT技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP协议"><span class="toc-number">3.6.</span> <span class="toc-text">ICMP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP协议的应用"><span class="toc-number">3.7.</span> <span class="toc-text">ICMP协议的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络层的路由概述"><span class="toc-number">3.8.</span> <span class="toc-text">网络层的路由概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部网关路由协议"><span class="toc-number">3.9.</span> <span class="toc-text">内部网关路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RIP协议"><span class="toc-number">3.9.1.</span> <span class="toc-text">RIP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra算法-求最短路径"><span class="toc-number">3.9.2.</span> <span class="toc-text">Dijkstra算法(求最短路径)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF协议"><span class="toc-number">3.9.3.</span> <span class="toc-text">OSPF协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部网关路由协议之BGP协议"><span class="toc-number">3.10.</span> <span class="toc-text">外部网关路由协议之BGP协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#传输层"><span class="toc-number">4.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP协议"><span class="toc-number">4.1.</span> <span class="toc-text">UDP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议"><span class="toc-number">4.2.</span> <span class="toc-text">TCP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠传输的基本原理"><span class="toc-number">4.3.</span> <span class="toc-text">可靠传输的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议的可靠传输-基于ARQ协议"><span class="toc-number">4.4.</span> <span class="toc-text">TCP协议的可靠传输(基于ARQ协议)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议的流量控制"><span class="toc-number">4.5.</span> <span class="toc-text">TCP协议的流量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议的拥塞控制"><span class="toc-number">4.6.</span> <span class="toc-text">TCP协议的拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP连接的建立-三次握手"><span class="toc-number">4.7.</span> <span class="toc-text">TCP连接的建立(三次握手)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP连接的释放-四次挥手"><span class="toc-number">4.8.</span> <span class="toc-text">TCP连接的释放(四次挥手)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字与套接字的编程"><span class="toc-number">4.9.</span> <span class="toc-text">套接字与套接字的编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用层"><span class="toc-number">5.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单介绍"><span class="toc-number">5.1.</span> <span class="toc-text">简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">5.2.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DHCP协议"><span class="toc-number">5.3.</span> <span class="toc-text">DHCP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP协议"><span class="toc-number">5.4.</span> <span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP工作的结构"><span class="toc-number">5.5.</span> <span class="toc-text">HTTP工作的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS协议"><span class="toc-number">5.6.</span> <span class="toc-text">HTTPS协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实践环节"><span class="toc-number">6.</span> <span class="toc-text">实践环节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于之前的操作系统实践搭建服务器基本框架"><span class="toc-number">6.1.</span> <span class="toc-text">基于之前的操作系统实践搭建服务器基本框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈谈python如何操作字节序列"><span class="toc-number">6.2.</span> <span class="toc-text">谈谈python如何操作字节序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP报文解析器"><span class="toc-number">6.3.</span> <span class="toc-text">IP报文解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP报文解析器"><span class="toc-number">6.4.</span> <span class="toc-text">UDP报文解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP报文解析器"><span class="toc-number">6.5.</span> <span class="toc-text">TCP报文解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用TCP，UDP，IP报文解析器"><span class="toc-number">6.6.</span> <span class="toc-text">调用TCP，UDP，IP报文解析器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#博主寄语"><span class="toc-number">7.</span> <span class="toc-text">博主寄语</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>